/*
 * $Id$
 * This file is a part of the Arakhne Foundation Classes, http://www.arakhne.org/afc
 *
 * Copyright (c) 2000-2012 Stephane GALLAND.
 * Copyright (c) 2005-10, Multiagent Team, Laboratoire Systemes et Transports,
 *                        Universite de Technologie de Belfort-Montbeliard.
 * Copyright (c) 2013-2020 The original authors, and other authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.arakhne.afc.io.dbase;

import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.URI;
import java.net.URL;
import java.nio.channels.Channels;
import java.nio.channels.ReadableByteChannel;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.TreeMap;
import java.util.UUID;
import java.util.Vector;

import org.eclipse.xtext.xbase.lib.Pure;

import org.arakhne.afc.attrs.attr.Attribute;
import org.arakhne.afc.attrs.attr.AttributeException;
import org.arakhne.afc.attrs.attr.AttributeImpl;
import org.arakhne.afc.attrs.attr.AttributeNotInitializedException;
import org.arakhne.afc.attrs.attr.AttributeType;
import org.arakhne.afc.attrs.attr.AttributeValue;
import org.arakhne.afc.attrs.attr.AttributeValueImpl;
import org.arakhne.afc.attrs.attr.InvalidAttributeTypeException;
import org.arakhne.afc.attrs.collection.AttributeIterator;
import org.arakhne.afc.attrs.collection.AttributeProvider;
import org.arakhne.afc.inputoutput.endian.EndianNumbers;
import org.arakhne.afc.inputoutput.stream.LittleEndianDataInputStream;
import org.arakhne.afc.util.OutputParameter;
import org.arakhne.afc.vmutil.json.JsonBuffer;
import org.arakhne.afc.vmutil.locale.Locale;


/**
 * This class permits to read a dBASE file which is
 * typically generated by a GIS.
 *
 * <p>This class supports dBASE version 5. Version 7 specification is
 * available at <a href="http://www.dbase.com/KnowledgeBase/int/db7_file_fmt.htm">http://www.dbase.com/KnowledgeBase/int/db7_file_fmt.htm</a>.
 *
 * <h3>ESRi Limitations</h3>
 *
 * <p>Additionally, this writer includes the ESRi restrictions on dBASE files.
 * Shapefile feature attributes are stored in an associated .dbf file, and so
 * attributes suffer a number of limitations.
 *
 * <p>Attribute names can only be up
 * to 10 characters long.  Longer names will be silently truncated.
 * This may result in non-unique column names, which will definitely cause
 * problems later. Starting with version 1.7, the OGR Shapefile driver tries
 * to generate unique field names. Successive duplicate field names, including
 * those created by truncation to 10 characters, will be truncated to 8
 * characters and appended with a serial number from 1 to 99.
 *
 * <p>Only Integer, Real, String and Date (not DateTime, just year/month/day)
 * field types are supported.  The various list, and binary field types cannot
 * be created.
 *
 * <p>The field width and precision are directly used to establish storage
 * size in the .dbf file.  This means that strings longer than the field
 * width, or numbers that don't fit into the indicated field format will suffer
 * truncation.
 *
 * <p>Integer fields without an explicit width are treated as width 11.
 *
 * <p>Real (floating point) fields without an explicit width are treated as
 * width 24 with 15 decimal places of precision.
 *
 * <p>String fields without an assigned width are treated as 80 characters.
 *
 * <p>Also, .dbf files are required to have at least one field.  If none are created
 * by the application an "FID" field will be automatically created and populated
 * with the record number.
 *
 * <p>The OGR shapefile driver supports rewriting existing shapes in a shapefile
 * as well as deleting shapes.  Deleted shapes are marked for deletion in
 * the .dbf file, and then ignored by OGR.  To actually remove them permanently
 * (resulting in renumbering of FIDs) invoke the SQL 'REPACK &lt;tablename&gt;' via
 * the datasource ExecuteSQL() method.
 *
 * @author $Author: sgalland$
 * @author $Author: olamotte$
 * @version $FullVersion$
 * @mavengroupid $GroupId$
 * @mavenartifactid $ArtifactId$
 * @since 14.0
 */
@SuppressWarnings("checkstyle:classdataabstractioncoupling")
public class DBaseFileReader implements Iterable<AttributeProvider>, AutoCloseable {

	/** This option forces the reader to decode the string
	 * read from dBASE files.
	 * The decoding is based on {@link Locale#decodeString(byte[])}
	 * and could be time-consuming.
	 *
	 * <p>If this option was not set, this dBASE reader will not decode
	 * the strings. It means that the strings could contains not
	 * printable characters according to the default character set
	 * (UTF or ISO).
	 *
	 * <p>This option was set by default.
	 */
	public static final int OPTION_DECODE_STRING = 1;

	private static final String TRUE_CHARS = "YyTtOo"; //$NON-NLS-1$

	private static final String FALSE_CHARS = "NnFf"; //$NON-NLS-1$

	/** Stream used for reading the DBF file.
	 */
	private final LittleEndianDataInputStream stream;

	/** Count of records in the DBF file.
	 */
	private transient int recordCount = -1;

	/** Count of bytes inside a record.
	 */
	private int recordSize = -1;

	/** Count of fields in the DBF file.
	 */
	private transient int fieldCount = -1;

	/** Position of the reading head inside the list
	 * of records. The value of this attribute
	 * also corresponds to the index of the next
	 * record to read.
	 */
	private transient int readingPosition;

	/** Offset of the first record.
	 */
	private int firstRecordOffset = -1;

	/** Defined fields.
	 */
	private transient ArrayList<DBaseFileField> fields;

	/** List of columns that must be replied.
	 */
	private transient List<DBaseFileField> selectedColumns = new ArrayList<>();

	/** Indicates if the reader was closed.
	 */
	private boolean finished;

	/** List of writing options.
	 */
	private int options = OPTION_DECODE_STRING;

	/** Date of the last update of the DBF file.
	 * @since 4.0
	 */
	private Date lastUpdateDate;

	/** Language code of the dBASE file.
	 * @since 4.0
	 */
	private DBaseCodePage codePage;

	/** Version of the file.
	 * @since 4.0
	 */
	private int fileVersion;

	/** Constructor.
	 *
	 * @param inputStream is the stream to read.
	 */
	@SuppressWarnings("resource")
	public DBaseFileReader(InputStream inputStream) {
		this.stream = (inputStream instanceof LittleEndianDataInputStream)
				? (LittleEndianDataInputStream) inputStream : new LittleEndianDataInputStream(inputStream);
	}

	/** Constructor.
	 *
	 * @param file is the file to read.
	 * @throws IOException in case of error.
	 */
	@SuppressWarnings("resource")
	public DBaseFileReader(File file) throws IOException {
		this(new FileInputStream(file));
	}

	/** Constructor.
	 *
	 * @param url is the URL to read.
	 * @throws IOException in case of error.
	 */
	public DBaseFileReader(URL url) throws IOException {
		this(url.openStream());
	}

	/** Constructor.
	 *
	 * @param channel is the channel to read.
	 */
	public DBaseFileReader(ReadableByteChannel channel) {
		this(Channels.newInputStream(channel));
	}

	private static String columnize(String string, int length) {
		final StringBuilder b = new StringBuilder();
		b.append(string);
		for (int i = string.length(); i < length; ++i) {
			b.append(" "); //$NON-NLS-1$
		}
		String ss = b.toString();
		if (ss.length() > length) {
			ss = ss.substring(0, length);
		}
		return ss;
	}

	/** Main program to display the content of the dBASE file.
	 * This program works in a similar way than the dbview unix
	 * command.
	 *
	 * @param args command line arguments.
	 * @throws IOException in case of error.
	 */
	@SuppressWarnings({"checkstyle:regexp", "checkstyle:magicnumber"})
	public static void main(String[] args) throws IOException {
		for (final String filename : args) {
			final File file = new File(filename);
			try (DBaseFileReader reader = new DBaseFileReader(file)) {
				reader.readDBFHeader();
				final List<DBaseFileField> fields = reader.readDBFFields();

				System.out.println(Locale.getString(DBaseFileReader.class, "FILE_VERSION", reader.getDBFVersion())); //$NON-NLS-1$
				System.out.println(Locale.getString(DBaseFileReader.class, "LAST_UPDATE", //$NON-NLS-1$
						reader.getDBFLastUpdateDate()));
				System.out.println(Locale.getString(DBaseFileReader.class, "CHARSET", reader.getDBFLanguage())); //$NON-NLS-1$
				System.out.println(Locale.getString(DBaseFileReader.class, "FIELD_COUNT", //$NON-NLS-1$
						reader.getDBFFieldCount()));
				System.out.println(Locale.getString(DBaseFileReader.class, "RECORD_COUNT", //$NON-NLS-1$
						reader.getDBFRecordCount()));
				System.out.println(Locale.getString(DBaseFileReader.class, "RECORD_LENGTH", //$NON-NLS-1$
						reader.getDBFRecordSize()));
				System.out.println(Locale.getString(DBaseFileReader.class, "HEADER_LENGTH", //$NON-NLS-1$
						reader.getDBFHeaderSize()));

				System.out.println("------------------------------------------"); //$NON-NLS-1$
				System.out.println(Locale.getString(DBaseFileReader.class, "FIELD_HEADER")); //$NON-NLS-1$

				for (final DBaseFileField field : fields) {
					System.out.println(Locale.getString(DBaseFileReader.class, "FIELD", //$NON-NLS-1$
							columnize(field.getName(), 10),
							(char) field.getType().toByte(),
							field.getLength(),
							field.getDecimalPointPosition()));
				}

				System.out.println("=========================================="); //$NON-NLS-1$

				boolean first = true;

				for (final AttributeProvider attrs : reader) {
					if (first) {
						first = false;
					} else {
						System.out.println("------------------------------------------"); //$NON-NLS-1$
					}
					for (final Attribute attr : attrs.attributes()) {
						try {
							System.out.println(Locale.getString(DBaseFileReader.class, "RECORD_VALUE", //$NON-NLS-1$
									columnize(attr.getName(), 10),
									attr.getValue(), attr.getType()));
						} catch (InvalidAttributeTypeException e) {
							System.out.println(Locale.getString(DBaseFileReader.class,
									"INVALID_ATTRIBUTE_TYPE",  //$NON-NLS-1$
									columnize(attr.getName(), 10), attr.getType()));
						} catch (AttributeNotInitializedException e) {
							System.out.println(Locale.getString(DBaseFileReader.class,
									"ATTRIBUTE_NOT_INITIALIZED", //$NON-NLS-1$
									columnize(attr.getName(), 10)));
						}
					}
				}
			}
		}
	}

	/** Replies if the specified option was set.
	 *
	 * @param option is the option to test
	 * @return <code>true</code> if the given option was previously set,
	 *     otherwise <code>false</code>.
	 * @see #OPTION_DECODE_STRING
	 */
	@Pure
	public boolean hasOption(int option) {
		return (this.options & option) != 0;
	}

	/** Add the specified option.
	 *
	 * @param option is the option to set.
	 * @see #OPTION_DECODE_STRING
	 */
	public void addOption(int option) {
		this.options = this.options | option;
	}

	/** Remove the specified option.
	 *
	 * @param option is the option to remove
	 * @see #OPTION_DECODE_STRING
	 */
	public void removeOption(int option) {
		this.options = this.options & (~option);
	}

	/** Set or unset the specified option.
	 *
	 * @param option is the option to set or unset.
	 * @param option_is_set is <code>true</code> to set the given option, or <code>false</code>
	 *     to unset it.
	 * @see #OPTION_DECODE_STRING
	 */
	public void setOption(int option, boolean option_is_set) {
		if (option_is_set) {
			addOption(option);
		} else {
			removeOption(option);
		}
	}

	@Override
	public void close() throws IOException {
		this.finished = true;
		this.stream.close();
	}

	/** Replies if the stream was closed.
	 *
	 * @return <code>true</code> if the input stream is closed, otherwise <code>false</code>.
	 */
	@Pure
	public boolean isClosed() {
		return this.finished;
	}

	/** Replies the count of records.
	 *
	 * @return the count of records.
	 * @throws MustCallReadHeaderFunctionException if the header must be read before.
	 */
	@Pure
	public int getDBFRecordCount() throws MustCallReadHeaderFunctionException {
		if (this.recordCount == -1) {
			throw new MustCallReadHeaderFunctionException();
		}
		return this.recordCount;
	}

	/** Replies the size of a record in bytes.
	 *
	 * @return the size of a record in bytes.
	 * @throws MustCallReadHeaderFunctionException if the header must be read before.
	 */
	@Pure
	public int getDBFRecordSize() throws MustCallReadHeaderFunctionException {
		if (this.recordCount == -1) {
			throw new MustCallReadHeaderFunctionException();
		}
		return this.recordSize;
	}

	/** Replies the size of the header in bytes.
	 *
	 * @return the size of the header in bytes.
	 * @throws MustCallReadHeaderFunctionException if the header must be read before.
	 * @since 4.0
	 */
	@Pure
	@SuppressWarnings("checkstyle:magicnumber")
	public int getDBFHeaderSize() throws MustCallReadHeaderFunctionException {
		if (this.fieldCount == -1) {
			throw new MustCallReadHeaderFunctionException();
		}
		return 32 + this.fieldCount * 32 + 1;
	}

	/** Replies the count of columns.
	 *
	 * @return the count of columns.
	 * @throws MustCallReadHeaderFunctionException if the header must be read before.
	 */
	@Pure
	public int getDBFFieldCount() throws MustCallReadHeaderFunctionException {
		if (this.fieldCount == -1) {
			throw new MustCallReadHeaderFunctionException();
		}
		return this.fieldCount;
	}

	/** Replies the date of the last update of the DBF file.
	 *
	 * @return the date or <code>null</code> of the date is unknown.
	 * @since 4.0
	 */
	@Pure
	public Date getDBFLastUpdateDate() {
		return this.lastUpdateDate;
	}

	/** Replies the language used in the dBASE file.
	 *
	 * @return the language used in the dBASE file, or <code>null</code> if unknown.
	 * @since 4.0
	 */
	@Pure
	public DBaseCodePage getDBFLanguage() {
		return this.codePage;
	}

	/** Replies the version of the DBF file.
	 *
	 * @return the version of the DBF file.
	 * @since 4.0
	 */
	@Pure
	public int getDBFVersion() {
		return this.fileVersion;
	}

	/**
	 * Read the header of the DBF file.
	 *
	 * @throws IOException in case of error.
	 * @throws EOFDBaseFileException eof of file is reached from the database.
	 */
	@SuppressWarnings("checkstyle:magicnumber")
	public void readDBFHeader() throws IOException {
		if (this.finished) {
			throw new EOFDBaseFileException();
		}
		if (this.fieldCount != -1) {
			// The header was already red
			return;
		}

		//-----------------------------------------------------------
		// Bytes       Size   Content
		//-----------------------------------------------------------
		//    0      1 byte   DBF Format id
		//                    0x03: FoxBase+, FoxPro, dBASEIII+
		//                          dBASEIV, no memo
		//                    0x83: FoxBase+, dBASEIII+ with memo
		//                    0xF5: FoxPro with memo
		//                    0x8B: dBASEIV with memo
		//                    0x8E: dBASEIV with SQL table
		this.fileVersion = this.stream.readByte();

		//-----------------------------------------------------------
		// Bytes       Size   Content
		//-----------------------------------------------------------
		//  1-3     3 bytes   Date of last update: YMD
		final Calendar cal = new GregorianCalendar();
		cal.set(Calendar.YEAR, this.stream.readByte() + 1900);
		cal.set(Calendar.MONTH, this.stream.readByte() - 1);
		cal.set(Calendar.DAY_OF_MONTH, this.stream.readByte());
		this.lastUpdateDate = cal.getTime();

		// Get the count of records
		//
		//-----------------------------------------------------------
		// Bytes       Size   Content
		//-----------------------------------------------------------
		//   4-7    4 bytes   Number of records in the table
		this.recordCount = this.stream.readLEInt();

		// Get the count of fields (nbBytes / size of a Field - ending byte ODh)
		//
		//-----------------------------------------------------------
		// Bytes       Size   Content
		//-----------------------------------------------------------
		//   8-9    2 bytes   Number of bytes in the header

		// #bytes = 32 + 32 * #fields + 1;
		this.fieldCount = (this.stream.readLEShort() - 1) / 32 - 1;

		// Skip the ending chars of the header
		//
		//-----------------------------------------------------------
		// Bytes       Size   Content
		//-----------------------------------------------------------
		// 10-11    2 bytes   Number of bytes in the record
		this.recordSize = this.stream.readLEShort();

		//-----------------------------------------------------------
		// Bytes       Size   Content
		//-----------------------------------------------------------
		// 12-13     2 bytes   Reserved
		//    14     1 byte    Incomplete transaction
		//                     0x00: Ignored / Transaction End
		//                     0x01: Transaction started
		//    15     1 byte    Encryption flag
		//                     0x00: Not encrypted
		//                     0x01: Encrypted
		// 16-19     4 bytes   Free record thread (reserved for LAN only)
		// 20-27     8 bytes   Reserved for multi-user dBASE (dBASE III+)
		//    28     1 byte    MDX flag (dBASE IV)
		//                     0x00: index upon demand
		//                     0x01: production index exists
		this.stream.skipBytes(17);
		// use skipBytes because it force to skip the specified amount, instead of skip()

		//-----------------------------------------------------------
		// Bytes       Size   Content
		//-----------------------------------------------------------
		//    29     1 byte    Language driver ID
		//                     See {@link DBaseCodePage} for details.
		final byte b = this.stream.readByte();
		this.codePage = DBaseCodePage.fromLanguageCode(b);

		//-----------------------------------------------------------
		// Bytes       Size   Content
		//-----------------------------------------------------------
		// 30-31     2 bytes   Reserved
		this.stream.skipBytes(2);
		// use skipBytes because it force to skip the specified amount, instead of skip()

		// Update the offset of the first record with the size of the header
		this.firstRecordOffset = 32;
	}

	/**
	 * Read the field definitions.
	 * Multiple calls to this method will return always the
	 * same data structure. The column list is red only
	 * at the first call to this function.
	 * So you could use this method to obtain the list
	 * of the dBASE file's columns.
	 *
	 * <p>Instead of {@link #readDBFFields()}, this method
	 * does not throws any exception. It prefers to
	 * return the value <code>null</code>.
	 *
	 * @return all the columns or <code>null</code>
	 * @see #readDBFFields()
	 */
	@Pure
	public List<DBaseFileField> getDBFFields() {
		try {
			return readDBFFields();
		} catch (IOException e) {
			return null;
		}
	}

	/**
	 * Replies the name of the i-th field.
	 *
	 * @param index the index.
	 * @return the name or <code>null</code> if the function {@link #readDBFFields()}
	 *     was never called.
	 */
	@Pure
	public String getDBFFieldName(int index) {
		if (this.fieldCount != -1) {
			try {
				final DBaseFileField field = this.fields.get(index);
				if (field != null) {
					return field.getName();
				}
			} catch (Exception exception) {
				//
			}
		}
		return null;
	}

	/**
	 * Replies the column index of the specified column name.
	 *
	 * @param name the field name.
	 * @return the index or <code>-1</code> if the columns was not found
	 *     or the function {@link #readDBFFields()} was never called
	 */
	@Pure
	public int getDBFFieldIndex(String name) {
		assert name != null;
		if (this.fieldCount != -1) {
			try {
				int i = 0;
				for (final DBaseFileField field : this.fields) {
					if (field != null && name.equals(field.getName())) {
						return i;
					}
					++i;
				}
			} catch (Exception exception) {
				//
			}
		}
		return -1;
	}

	/**
	 * Replies the type of the i-th field.
	 *
	 * @param index the index.
	 * @return the type or <code>null</code> if the function {@link #readDBFFields()}
	 *     was never called.
	 */
	@Pure
	public DBaseFieldType getDBFFieldType(int index) {
		if (this.fieldCount != -1) {
			try {
				final DBaseFileField field = this.fields.get(index);
				if (field != null) {
					return field.getType();
				}
			} catch (Exception exception) {
				//
			}
		}
		return null;
	}

	/**
	 * Read the field definitions.
	 * Multiple calls to this method will return always the
	 * same data structure. The column list is red only
	 * at the first call to this function.
	 * So you could use this method to obtain the list
	 * of the dBASE file's columns.
	 *
	 * <p>Instead of {@link #getDBFFields()}, this method
	 * does not returns the value <code>null</code>. It
	 * prefers to throw an exception.
	 *
	 * @return all the columns
	 * @throws IOException if the stream cannot be read.
	 * @throws EOFException if unexpected end-of-file.
	 * @see #getDBFFields()
	 */
	@SuppressWarnings({"checkstyle:npathcomplexity", "checkstyle:magicnumber"})
	public List<DBaseFileField> readDBFFields() throws IOException, EOFException {
		if (this.fields != null) {
			return this.fields;
		}
		if (this.finished) {
			throw new EOFDBaseFileException();
		}
		if (this.fieldCount == -1) {
			throw new MustCallReadHeaderFunctionException();
		}

		//
		//-----------------------------------------------------------
		// Bytes       Size   Content
		//-----------------------------------------------------------
		// 32-m  n*32 bytes   Field descriptors (see bellow)
		//  m+1     1 byte    terminator character 0x0D

		// A field contains at least the "removal flag" byte
		int byteSize = 1;
		final ArrayList<DBaseFileField> array = new ArrayList<>();
		final Charset charSet = (this.codePage == null) ? null : this.codePage.getChatset();
		String columnName;

		for (int idxFields = 0; idxFields < this.fieldCount; ++idxFields) {

			// Read the field header
			//
			//-----------------------------------------------------------
			// Bytes       Size   Content
			//-----------------------------------------------------------
			//  0-10   11 bytes   Field name, filled with 0x00
			//    11    1 byte    Field type (see bellow)
			// 12-15    4 bytes   Field data address, not useful for disk
			//    16    1 byte    Field length
			//    17    1 byte    Field decimal count
			// 18-19    2 bytes   Reserved for dBASE III+ on a Lan
			//    20    1 byte    Work area ID
			// 21-22    2 bytes   Reserved for dBASE III+ on a Lan
			//    23    1 byte    SET FIELDS flag
			// 24-31    7 bytes   Reserved
			final byte[] header = new byte[32];
			this.stream.readFully(header);

			// Update the offset of the first record with the end-of-header character
			this.firstRecordOffset += header.length;

			// Read the name of the field until 0x00
			int nbChars = 0;
			for (int i = 0; i <= 10; ++i) {
				if (header[i] == 0) {
					break;
				}
				++nbChars;
			}
			final byte[] bName = new byte[nbChars];
			System.arraycopy(header, 0, bName, 0, nbChars);
			if (charSet != null) {
				columnName = new String(bName, charSet);
			} else {
				columnName = new String(bName);
			}

			// Read the type
			final DBaseFieldType dbftype = DBaseFieldType.fromByte(header[11]);

			final DBaseFileField field = new DBaseFileField(
					columnName,
					dbftype,
					// convert unsigned byte into int
					header[16] & 0xFF,
					// convert unsigned byte into int
					header[17] & 0xFF,
					idxFields);
			array.add(field);
			byteSize += field.getLength();
		}

		// Check if the byte size of the field list corresponds to size specified record size inside the header
		if (byteSize != this.recordSize) {
			throw new InvalidRecordSizeException(this.recordSize, byteSize);
		}

		// Read the terminator character 0x0D
		final byte bt = this.stream.readByte();
		if (bt != 0x0D) {
			throw new InvalidDBaseFieldTerminationException(bt);
		}

		// Update the offset of the first record with the end-of-header character
		++this.firstRecordOffset;

		this.fields = array;

		// Save the position inside the input stream for seeking function
		if (this.stream.markSupported()) {
			this.stream.mark(this.recordSize * this.recordCount + this.firstRecordOffset + 1);
		}

		return array;
	}

	/** Read the next record.
	 *
	 * @return the next record from the input stream or {@code null} if none.
	 * @throws IOException in case of error.
	 * @throws MustCallReadHeaderFunctionException you must call a {@code readHeader()}
	 *     function prior to the call to this function.
	 * @see #readNextAttributeProvider()
	 */
	public DBaseFileRecord readNextDBFRecord() throws IOException {
		if (this.recordCount == -1) {
			throw new MustCallReadHeaderFunctionException();
		}
		if (this.readingPosition >= this.recordCount) {
			return null;
		}

		try {
			// Update the readingPosition attribute AFTER the call to the
			// reading function to avoid invalid usage of its value
			// by this function.
			final DBaseFileRecord record = readDBFRecord(this.readingPosition);
			++this.readingPosition;
			return record;
		} catch (EOFException e) {
			this.finished = true;
			return null;
		}
	}

	/** Move the reading head by the specified record count amount.
	 *
	 * <p>If the count of records to skip puts the reading head after
	 * the last record, the exception {@link EOFException} is thrown.
	 *
	 * @param skipAmount is the count of records to skip.
	 * @throws IOException in case of error.
	 * @throws MustCallReadHeaderFunctionException you must call a {@code readHeader()} function
	 *      prior to this function.
	 */
	public void skip(int skipAmount) throws IOException {
		if (this.recordCount == -1) {
			throw new MustCallReadHeaderFunctionException();
		}
		if ((this.readingPosition + skipAmount) >= this.recordCount) {
			throw new EOFException();
		}
		if (skipAmount > 0) {
			this.readingPosition += skipAmount;
			//this.stream.reset();
			//this.stream.skipBytes(this.recordSize * this.readingPosition);
			final long skippedAmount = this.stream.skipBytes(this.recordSize * skipAmount);
			// use skipBytes because it force to skip the specified amount, instead of skip()
			assert skippedAmount == this.recordSize * skipAmount;
		}
	}

	/** Move the reading head at the specified record index.
	 *
	 * <p>If the index is negative, the next record to read is assumed to be
	 * the first record.
	 * If the index is greater or equals to the count of records, the exception
	 * {@link EOFException} will be thrown.
	 *
	 * @param recordIndex is the index of record to reply at the next read.
	 * @throws IOException in case of error.
	 * @throws UnsupportedSeekOperationException seeking operation is not supported.
	 */
	public void seek(int recordIndex) throws IOException {
		if (!this.stream.markSupported()) {
			throw new UnsupportedSeekOperationException();
		}
		if (this.recordCount == -1) {
			throw new MustCallReadHeaderFunctionException();
		}
		int ri = recordIndex;
		if (ri < 0) {
			ri = 0;
		}
		if (ri >= this.recordCount) {
			throw new EOFException();
		}

		this.readingPosition = ri;
		// Goto the first record
		this.stream.reset();
		// Skip until the next record to read
		if (ri > 0) {
			// use skipBytes because it force to skip the specified amount, instead of skip()
			this.stream.skipBytes(this.recordSize * ri);
		}
	}

	/** Read the next record.
	 *
	 * <p>This function calls {@link #readNextDBFRecord()}
	 * and replies an attribute provider that corresponds to
	 * the corresponds DBase record.
	 *
	 * @return the next record from the input stream or {@code null} if none.
	 * @throws IOException in case of error.
	 * @see #readNextDBFRecord()
	 */
	public AttributeProvider readNextAttributeProvider() throws IOException {
		final DBaseFileRecord record = readNextDBFRecord();
		if (record == null) {
			return null;
		}
		return new RecordAttributeProvider(record);
	}

	/** Read all the records.
	 *
	 * <p><strong>This method close the input stream !!!</strong>
	 *
	 * <p>The returned value could take a lot
	 * of memory. In this case, the virtual machine
	 * could freeze when you try to access to the
	 * collection content.
	 *
	 * @return all the records
	 * @throws IOException in case of error.
	 * @throws EOFDBaseFileException if there is no more record to be read.
	 */
	public List<DBaseFileRecord> readRestOfDBFRecords() throws IOException {
		if (this.finished) {
			throw new EOFDBaseFileException();
		}
		if (this.recordCount == -1) {
			throw new MustCallReadHeaderFunctionException();
		}

		final Vector<DBaseFileRecord> records = new Vector<>();
		try {
			while (this.readingPosition < this.recordCount) {
				final DBaseFileRecord record = readNextDBFRecord();
				if (record != null) {
					records.add(record);
				}
			}
		} catch (EOFException e) {
			//
		}
		this.finished = true;
		this.stream.close();
		return records;
	}

	/**
	 * Read a records.
	 *
	 * @param recordNumber is the number of the record to read, from {@code 0} to {@link #recordCount} (exclusive).
	 * @return a record
	 * @throws IOException in case of error.
	 */
	@SuppressWarnings({"checkstyle:cyclomaticcomplexity", "checkstyle:npathcomplexity", "checkstyle:magicnumber"})
	private DBaseFileRecord readDBFRecord(int recordNumber) throws IOException {
		if (this.finished) {
			throw new EOFDBaseFileException();
		}
		if (this.fields == null) {
			throw new MustCallReadHeaderFunctionException();
		}

		//
		//-----------------------------------------------------------
		// Bytes       Size   Content
		//-----------------------------------------------------------
		//     0    1 byte    deleted flag:
		//                    '*' (star) if deleted
		//                    ' ' (space) if not deleted
		//  1..m    n bytes   contents of fields, for n see
		//                    the bytes 10..11 of the dBASE header

		// Compute the offset
		final long offset = this.readingPosition * this.recordSize + this.firstRecordOffset;

		// Read the record
		final byte[] rawData = new byte[this.recordSize];
		this.stream.readFully(rawData);

		// Read the deleted flag
		final int deletedFlag = rawData[0] & 0xFF;
		if (deletedFlag == 0x1A) {
			// END-OF-FILE character
			throw new EOFException();
		}
		if (deletedFlag != '*' && deletedFlag != ' ') {
			throw new InvalidDeletionFlagFormatException(recordNumber, deletedFlag);
		}
		if (deletedFlag == '*') {
			return null;
		}

		int rawOffset = 1;

		final DBaseFileRecord record = new DBaseFileRecord(recordNumber, offset);
		for (int i = 0; i < this.fieldCount; ++i) {

			final DBaseFileField field = this.fields.get(i);
			if (field != null) {

				Object value = null;

				// Read the content of the record
				switch (field.getType()) {
				//
				// Read a list of characters
				case STRING:
					final OutputParameter<String> strvalue = new OutputParameter<>();
					rawOffset += readStringRecordValue(
							field,
							recordNumber, i + 1,
							rawData, rawOffset,
							strvalue);
					value = strvalue.get();
					break;
				//
				// Read a date
				case DATE:
					final OutputParameter<Date> datevalue = new OutputParameter<>();
					rawOffset += readDateRecordValue(field, recordNumber, i + 1, rawData, rawOffset, datevalue);
					value = datevalue.get();
					break;
				//
				// Read a number
				case NUMBER:
				case FLOATING_NUMBER:
					final OutputParameter<Double> dblvalue = new OutputParameter<>();
					rawOffset += readNumberRecordValue(field, recordNumber, i + 1, rawData, rawOffset, dblvalue);
					value = dblvalue.get();
					break;
				//
				// Read a boolean
				case BOOLEAN:
					final OutputParameter<Boolean> boolvalue = new OutputParameter<>();
					rawOffset += readBooleanRecordValue(field, recordNumber, i + 1, rawData, rawOffset, boolvalue);
					value = boolvalue.get();
					break;
				//
				// Read a 2 byte integer
				case INTEGER_2BYTES:
					final OutputParameter<Integer> intvalue = new OutputParameter<>();
					rawOffset += read2ByteIntegerRecordValue(field, recordNumber, i + 1, rawData, rawOffset, intvalue);
					value = intvalue.get();
					break;
				//
				// Read a 4 byte integer
				case INTEGER_4BYTES:
					final OutputParameter<Long> longvalue = new OutputParameter<>();
					rawOffset += read4ByteIntegerRecordValue(field, recordNumber, i + 1, rawData, rawOffset, longvalue);
					value = longvalue.get();
					break;
				//
				// Read a 8 byte double
				case DOUBLE:
					final OutputParameter<Double> dblvalue2 = new OutputParameter<>();
					rawOffset += read8ByteDoubleRecordValue(field, recordNumber, i + 1, rawData, rawOffset, dblvalue2);
					value = dblvalue2.get();
					break;
					//$CASES-OMITTED$
				default:
				}

				if (value != null) {
					record.add(value);
				} else {
					record.add(null);
				}
			}

		}

		return record;
	}

	/** Read a STRING record value.
	 *
	 * @param field is the current parsed field.
	 * @param nrecord is the number of the record
	 * @param nfield is the number of the field
	 * @param rawData raw data
	 * @param rawOffset is the index at which the data could be obtained
	 * @param value will be set with the value extracted from the dBASE file
	 * @return the count of consumed bytes
	 * @throws IOException in case of error.
	 */
	private int readStringRecordValue(DBaseFileField field, int nrecord, int nfield, byte[] rawData,
			int rawOffset, OutputParameter<String> value) throws IOException {
		final byte[] recordData = new byte[field.getLength()];
		System.arraycopy(rawData, rawOffset, recordData, 0, recordData.length);

		String data;
		if (hasOption(OPTION_DECODE_STRING)) {
			data = Locale.decodeString(recordData).trim();
		} else {
			data = new String(recordData).trim();
		}

		// ignore the data that does not contain anything
		if (data == null || data.length() == 0 || DBaseFileField.isUnsetValue(data)) {
			data = null;
		}
		value.set(data);
		return recordData.length;
	}

	/** Read a DATE record value.
	 *
	 * @param field is the current parsed field.
	 * @param nrecord is the number of the record
	 * @param nfield is the number of the field
	 * @param rawData raw data
	 * @param rawOffset is the index at which the data could be obtained
	 * @param value will be set with the value extracted from the dBASE file
	 * @return the count of consumed bytes
	 * @throws IOException in case of error.
	 */
	@SuppressWarnings("checkstyle:magicnumber")
	private static int readDateRecordValue(DBaseFileField field, int nrecord, int nfield, byte[] rawData,
			int rawOffset, OutputParameter<Date> value) throws IOException {
		final GregorianCalendar cal = new GregorianCalendar();
		final int year = ((rawData[rawOffset] & 0xFF) - '0') * 1000
				+ ((rawData[rawOffset + 1] & 0xFF) - '0') * 100
				+ ((rawData[rawOffset + 2] & 0xFF) - '0') * 10
				+ ((rawData[rawOffset + 3] & 0xFF) - '0');
		final int month = ((rawData[rawOffset + 4] & 0xFF) - '0') * 10
				+ ((rawData[rawOffset + 5] & 0xFF) - '0');
		final int day = ((rawData[rawOffset + 6] & 0xFF) - '0') * 10
				+ ((rawData[rawOffset + 7] & 0xFF) - '0');
		cal.set(Calendar.YEAR, year);
		cal.set(Calendar.MONTH, month);
		cal.set(Calendar.DAY_OF_MONTH, day);

		if (year == cal.get(Calendar.YEAR) && month == cal.get(Calendar.MONTH)
				&& day == cal.get(Calendar.DAY_OF_MONTH)) {
			value.set(cal.getTime());
			return 8;
		}

		throw new InvalidRawDataFormatException(nrecord, nfield, new String(rawData, rawOffset, field.getLength()));
	}

	/** Read a NUMBER record value.
	 *
	 * @param field is the current parsed field.
	 * @param nrecord is the number of the record
	 * @param nfield is the number of the field
	 * @param rawData raw data
	 * @param rawOffset is the index at which the data could be obtained
	 * @param value will be set with the value extracted from the dBASE file
	 * @return the count of consumed bytes
	 * @throws IOException in case of error.
	 */
	private static int readNumberRecordValue(DBaseFileField field, int nrecord, int nfield, byte[] rawData,
			int rawOffset, OutputParameter<Double> value) throws IOException {
		final String buffer = new String(rawData, rawOffset, field.getLength());
		try {
			final String b = buffer.trim();
			if (b != null && b.length() > 0) {
				value.set(Double.valueOf(b));
				return field.getLength();
			}
		} catch (NumberFormatException e) {
			//
		}
		throw new InvalidRawDataFormatException(nrecord, nfield, buffer);
	}

	/** Read a BOOLEAN record value.
	 *
	 * @param field is the current parsed field.
	 * @param nrecord is the number of the record
	 * @param nfield is the number of the field
	 * @param rawData raw data
	 * @param rawOffset is the index at which the data could be obtained
	 * @param value will be set with the value extracted from the dBASE file
	 * @return the count of consumed bytes
	 * @throws IOException in case of error.
	 */
	@SuppressWarnings("checkstyle:magicnumber")
	private static int readBooleanRecordValue(DBaseFileField field, int nrecord, int nfield, byte[] rawData,
			int rawOffset, OutputParameter<Boolean> value) throws IOException {
		final int byteCode = rawData[rawOffset] & 0xFF;

		if (TRUE_CHARS.indexOf(byteCode) != -1) {
			value.set(true);
			return 1;
		}

		if (FALSE_CHARS.indexOf(byteCode) != -1) {
			value.set(false);
			return 1;
		}

		throw new InvalidRawDataFormatException(nrecord, nfield, Integer.toString(byteCode));
	}

	/** Read a 2 BYTE INTEGER record value.
	 *
	 * @param field is the current parsed field.
	 * @param nrecord is the number of the record
	 * @param nfield is the number of the field
	 * @param rawData raw data
	 * @param rawOffset is the index at which the data could be obtained
	 * @param value will be set with the value extracted from the dBASE file
	 * @return the count of consumed bytes
	 * @throws IOException in case of error.
	 */
	private static int read2ByteIntegerRecordValue(DBaseFileField field, int nrecord, int nfield,
			byte[] rawData, int rawOffset, OutputParameter<Integer> value) throws IOException {
		final short rawNumber = EndianNumbers.toLEShort(rawData[rawOffset], rawData[rawOffset + 1]);
		try {
			value.set(Integer.valueOf(rawNumber));
			return 2;
		} catch (NumberFormatException exception) {
			throw new InvalidRawDataFormatException(nrecord, nfield, Short.toString(rawNumber));
		}
	}

	/** Read a 4 BYTE INTEGER record value.
	 *
	 * @param field is the current parsed field.
	 * @param nrecord is the number of the record
	 * @param nfield is the number of the field
	 * @param rawData raw data
	 * @param rawOffset is the index at which the data could be obtained
	 * @param value will be set with the value extracted from the dBASE file
	 * @return the count of consumed bytes
	 * @throws IOException in case of error.
	 */
	@SuppressWarnings("checkstyle:magicnumber")
	private static int read4ByteIntegerRecordValue(DBaseFileField field, int nrecord, int nfield,
			byte[] rawData, int rawOffset, OutputParameter<Long> value) throws IOException {
		final int rawNumber = EndianNumbers.toLEInt(
				rawData[rawOffset], rawData[rawOffset + 1],
				rawData[rawOffset + 2], rawData[rawOffset + 3]);
		try {
			value.set(Long.valueOf(rawNumber));
			return 4;
		} catch (NumberFormatException exception) {
			throw new InvalidRawDataFormatException(nrecord, nfield, Long.toString(rawNumber));
		}
	}

	/** Read a 8 BYTE DOUBLE record value.
	 *
	 * @param field is the current parsed field.
	 * @param nrecord is the number of the record
	 * @param nfield is the number of the field
	 * @param rawData raw data
	 * @param rawOffset is the index at which the data could be obtained
	 * @param value will be set with the value extracted from the dBASE file
	 * @return the count of consumed bytes
	 * @throws IOException in case of error.
	 */
	@SuppressWarnings("checkstyle:magicnumber")
	private static int read8ByteDoubleRecordValue(DBaseFileField field, int nrecord, int nfield,
			byte[] rawData, int rawOffset, OutputParameter<Double> value) throws IOException {
		final double rawNumber = EndianNumbers.toLEDouble(
				rawData[rawOffset], rawData[rawOffset + 1],
				rawData[rawOffset + 2], rawData[rawOffset + 3],
				rawData[rawOffset + 4], rawData[rawOffset + 5],
				rawData[rawOffset + 6], rawData[rawOffset + 7]);
		try {
			value.set(Double.valueOf(rawNumber));
			return 8;
		} catch (NumberFormatException exception) {
			throw new InvalidRawDataFormatException(nrecord, nfield, Double.toString(rawNumber));
		}
	}

	/** Indicates to this reader that the specified column
	 * could be replied.
	 *
	 * @param column is the column allowed to be replied
	 */
	public void selectColumn(DBaseFileField column) {
		this.selectedColumns.add(column);
	}

	/** Clear the list of column that must be replied.
	 */
	public void selectAllColumns() {
		this.selectedColumns.clear();
	}

	/** Replies if the specified column could be replied or ignored.
	 *
	 * @param column the column.
	 * @return <code>true</code> if the given column is selectable, otherwise <code>false</code>
	 */
	@Pure
	public boolean isColumnSelectable(DBaseFileField column) {
		return column != null && (this.selectedColumns.isEmpty()
				|| this.selectedColumns.contains(column));
	}

	@Override
	@Pure
	public Iterator<AttributeProvider> iterator() {
		try {
			if (this.finished) {
				throw new EOFDBaseFileException();
			}
			return new RecordIterator();
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

	/**
	 * Iterator on DBase records.
	 *
	 * @author $Author: sgalland$
	 * @version $FullVersion$
	 * @mavengroupid $GroupId$
	 * @mavenartifactid $ArtifactId$
	 * @since 14.0
	 */
	private class RecordIterator implements Iterator<AttributeProvider> {

		private AttributeProvider nextRecord;

		/** Constructor.
		 *
		 * @throws MustCallReadHeaderFunctionException if the header must be read before.
		 * @throws IOException in case of error.
		 */
		RecordIterator() throws MustCallReadHeaderFunctionException, IOException {
			DBaseFileReader.this.readDBFHeader();
			DBaseFileReader.this.readDBFFields();
			this.nextRecord = DBaseFileReader.this.readNextAttributeProvider();
		}

		@Override
		public boolean hasNext() {
			return this.nextRecord != null;
		}

		@Override
		public AttributeProvider next() {
			if (this.nextRecord == null) {
				throw new NoSuchElementException();
			}

			final AttributeProvider toReply = this.nextRecord;

			try {
				this.nextRecord = DBaseFileReader.this.readNextAttributeProvider();
			} catch (Exception exception) {
				this.nextRecord = null;
			}

			return toReply;
		}

		@Override
		public void remove() {
			//
		}

	} /* class RecordIterator */

	/**
	 * Attribute provider mapped to a DBase record.
	 *
	 * @author $Author: sgalland$
	 * @version $FullVersion$
	 * @mavengroupid $GroupId$
	 * @mavenartifactid $ArtifactId$
	 * @since 14.0
	 */
	private class RecordAttributeProvider implements AttributeProvider, Iterable<Attribute> {

		private static final long serialVersionUID = 2626464633448999595L;

		private final DBaseFileRecord record;

		/** Constructor.
		 * @param record is the record from which data could be extracted.
		 */
		RecordAttributeProvider(DBaseFileRecord record) {
			this.record = record;
		}

		@Override
		public RecordAttributeProvider clone() {
			try {
				return (RecordAttributeProvider) super.clone();
			} catch (CloneNotSupportedException e) {
				throw new RuntimeException(e);
			}
		}

		/** Replies the column index for the specified name.
		 */
		private int getColumnIndex(String name) {
			try {
				for (int idx = 0; idx < DBaseFileReader.this.getDBFFieldCount(); ++idx) {
					if (name.equals(DBaseFileReader.this.getDBFFieldName(idx))) {
						return idx;
					}
				}
			} catch (Exception exception) {
				//
			}
			return -1;
		}

		/** Replies the best attribute type that corresponds to the dBASE column.
		 */
		private AttributeType getAttributeType(int columnIndex) {
			final DBaseFieldType dbfType = DBaseFileReader.this.getDBFFieldType(columnIndex);
			if (dbfType == null) {
				return null;
			}
			return dbfType.toAttributeType();
		}

		@Override
		public Collection<String> getAllAttributeNames() {
			final ArrayList<String> fieldNames = new ArrayList<>();
			for (final DBaseFileField field : DBaseFileReader.this.getDBFFields()) {
				fieldNames.add(field.getName());
			}
			return fieldNames;
		}

		@Override
		public Collection<Attribute> getAllAttributes() {
			final ArrayList<Attribute> attributes = new ArrayList<>();
			Attribute attr;
			int idx = 0;
			for (final Object value : this.record) {
				attr = new AttributeImpl(DBaseFileReader.this.getDBFFieldName(idx));
				attr.castAndSet(getAttributeType(idx), value);
				attributes.add(attr);
				++idx;
			}
			return attributes;
		}

		@Override
		public Map<AttributeType, Collection<Attribute>> getAllAttributesByType() {
			final Map<AttributeType, Collection<Attribute>> attributes = new TreeMap<>();
			Attribute attr;
			Collection<Attribute> list;
			AttributeType type;
			int idx = 0;
			for (final Object value : this.record) {
				attr = new AttributeImpl(DBaseFileReader.this.getDBFFieldName(idx));
				attr.castAndSet(getAttributeType(idx), value);

				type = attr.getType();
				list = attributes.get(type);
				if (list == null) {
					list = new ArrayList<>();
					attributes.put(type, list);
				}
				list.add(attr);

				++idx;
			}
			return attributes;
		}

		@Override
		public AttributeValue getAttribute(String name) {
			final int index = getColumnIndex(name);
			if (index != -1) {
				final AttributeValue attr = new AttributeValueImpl();
				attr.castAndSet(getAttributeType(index), this.record.getFieldValue(index));
				return attr;
			}
			return null;
		}

		@Override
		public AttributeValue getAttribute(String name, AttributeValue default_value) {
			final int index = getColumnIndex(name);
			if (index != -1) {
				final AttributeValue attr = new AttributeValueImpl();
				attr.castAndSet(getAttributeType(index), this.record.getFieldValue(index));
				return attr;
			}
			return default_value;
		}

		@Override
		public boolean getAttribute(String name, boolean defaultValue) {
			try {
				final AttributeValue v = getAttribute(name);
				if (v != null) {
					return v.getBoolean();
				}
			} catch (AttributeException exception) {
				//
			}
			return defaultValue;
		}

		@Override
		public double getAttribute(String name, double defaultValue) {
			try {
				final AttributeValue v = getAttribute(name);
				if (v != null) {
					return v.getReal();
				}
			} catch (AttributeException exception) {
				//
			}
			return defaultValue;
		}

		@Override
		public float getAttribute(String name, float defaultValue) {
			try {
				final AttributeValue v = getAttribute(name);
				if (v != null) {
					return (float) v.getReal();
				}
			} catch (AttributeException exception) {
				//
			}
			return defaultValue;
		}

		@Override
		public int getAttribute(String name, int defaultValue) {
			try {
				final AttributeValue v = getAttribute(name);
				if (v != null) {
					return (int) v.getInteger();
				}
			} catch (AttributeException exception) {
				//
			}
			return defaultValue;
		}

		@Override
		public long getAttribute(String name, long defaultValue) {
			try {
				final AttributeValue v = getAttribute(name);
				if (v != null) {
					return v.getInteger();
				}
			} catch (AttributeException exception) {
				//
			}
			return defaultValue;
		}

		@Override
		public String getAttribute(String name, String defaultValue) {
			try {
				final AttributeValue v = getAttribute(name);
				if (v != null) {
					return v.getString();
				}
			} catch (AttributeException exception) {
				//
			}
			return defaultValue;
		}

		@Override
		public UUID getAttribute(String name, UUID defaultValue) {
			try {
				final AttributeValue v = getAttribute(name);
				if (v != null) {
					return v.getUUID();
				}
			} catch (AttributeException exception) {
				//
			}
			return defaultValue;
		}

		@Override
		public URL getAttribute(String name, URL defaultValue) {
			try {
				final AttributeValue v = getAttribute(name);
				if (v != null) {
					return v.getURL();
				}
			} catch (AttributeException exception) {
				//
			}
			return defaultValue;
		}

		@Override
		public URI getAttribute(String name, URI defaultValue) {
			try {
				final AttributeValue v = getAttribute(name);
				if (v != null) {
					return v.getURI();
				}
			} catch (AttributeException exception) {
				//
			}
			return defaultValue;
		}

		@Override
		public Date getAttribute(String name, Date defaultValue) {
			try {
				final AttributeValue v = getAttribute(name);
				if (v != null) {
					return v.getDate();
				}
			} catch (AttributeException exception) {
				//
			}
			return defaultValue;
		}

		@Override
		public InetAddress getAttribute(String name, InetAddress defaultValue) {
			try {
				final AttributeValue v = getAttribute(name);
				if (v != null) {
					return v.getInetAddress();
				}
			} catch (AttributeException exception) {
				//
			}
			return defaultValue;
		}

		@Override
		public InetAddress getAttribute(String name, InetSocketAddress defaultValue) {
			try {
				final AttributeValue v = getAttribute(name);
				if (v != null) {
					return v.getInetAddress();
				}
			} catch (AttributeException exception) {
				//
			}
			return defaultValue == null ? null : defaultValue.getAddress();
		}

		@SuppressWarnings("unchecked")
		@Override
		public <T extends Enum<T>> T getAttribute(String name, T defaultValue) {
			try {
				final AttributeValue v = getAttribute(name);
				if (v != null) {
					return (T) v.getEnumeration(defaultValue.getClass());
				}
			} catch (AttributeException exception) {
				//
			}
			return defaultValue;
		}

		@Override
		public Class<?> getAttribute(String name, Class<?> defaultValue) {
			try {
				final AttributeValue v = getAttribute(name);
				if (v != null) {
					return v.getJavaClass();
				}
			} catch (AttributeException exception) {
				//
			}
			return defaultValue;
		}

		@Override
		public Attribute getAttributeObject(String name) {
			final int index = getColumnIndex(name);
			if (index != -1) {
				final Attribute attr = new AttributeImpl(name);
				attr.castAndSet(getAttributeType(index), this.record.getFieldValue(index));
				return attr;
			}
			return null;
		}

		@Override
		public boolean getAttributeAsBool(String name) throws AttributeException {
			final AttributeValue v = getAttribute(name);
			if (v != null) {
				return v.getBoolean();
			}
			throw new AttributeNotInitializedException();
		}

		@Override
		public double getAttributeAsDouble(String name) throws AttributeException {
			final AttributeValue v = getAttribute(name);
			if (v != null) {
				return v.getReal();
			}
			throw new AttributeNotInitializedException();
		}

		@Override
		public float getAttributeAsFloat(String name) throws AttributeException {
			final AttributeValue v = getAttribute(name);
			if (v != null) {
				return (float) v.getReal();
			}
			throw new AttributeNotInitializedException();
		}

		@Override
		public int getAttributeAsInt(String name) throws AttributeException {
			final AttributeValue v = getAttribute(name);
			if (v != null) {
				return (int) v.getInteger();
			}
			throw new AttributeNotInitializedException();
		}

		@Override
		public long getAttributeAsLong(String name) throws AttributeException {
			final AttributeValue v = getAttribute(name);
			if (v != null) {
				return v.getInteger();
			}
			throw new AttributeNotInitializedException();
		}

		@Override
		public String getAttributeAsString(String name) throws AttributeException {
			final AttributeValue v = getAttribute(name);
			if (v != null) {
				return v.getString();
			}
			throw new AttributeNotInitializedException();
		}

		@Override
		public UUID getAttributeAsUUID(String name) throws AttributeException {
			final AttributeValue v = getAttribute(name);
			if (v != null) {
				return v.getUUID();
			}
			throw new AttributeNotInitializedException();
		}

		@Override
		public URL getAttributeAsURL(String name) throws AttributeException {
			final AttributeValue v = getAttribute(name);
			if (v != null) {
				return v.getURL();
			}
			throw new AttributeNotInitializedException();
		}

		@Override
		public URI getAttributeAsURI(String name) throws AttributeException {
			final AttributeValue v = getAttribute(name);
			if (v != null) {
				return v.getURI();
			}
			throw new AttributeNotInitializedException();
		}

		@Override
		public Date getAttributeAsDate(String name) throws AttributeException {
			final AttributeValue v = getAttribute(name);
			if (v != null) {
				return v.getDate();
			}
			throw new AttributeNotInitializedException();
		}

		@Override
		public InetAddress getAttributeAsInetAddress(String name) throws AttributeException {
			final AttributeValue v = getAttribute(name);
			if (v != null) {
				return v.getInetAddress();
			}
			throw new AttributeNotInitializedException();
		}

		@Override
		public Enum<?> getAttributeAsEnumeration(String name) throws AttributeException {
			final AttributeValue v = getAttribute(name);
			if (v != null) {
				return v.getEnumeration();
			}
			throw new AttributeNotInitializedException();
		}

		@Override
		public <T extends Enum<T>> T getAttributeAsEnumeration(String name, Class<T> type) throws AttributeException {
			final AttributeValue v = getAttribute(name);
			if (v != null) {
				return v.getEnumeration(type);
			}
			throw new AttributeNotInitializedException();
		}

		@Override
		public Class<?> getAttributeAsJavaClass(String name) throws AttributeException {
			final AttributeValue v = getAttribute(name);
			if (v != null) {
				return v.getJavaClass();
			}
			throw new AttributeNotInitializedException();
		}

		@Override
		public int getAttributeCount() {
			return this.record.size();
		}

		@Override
		public boolean hasAttribute(String name) {
			return getColumnIndex(name) != -1;
		}

		@Override
		public Iterable<Attribute> attributes() {
			return this;
		}

		@Override
		public void freeMemory() {
			//
		}

		@Override
		public Iterator<Attribute> iterator() {
			return new AttributeIterator(this);
		}

		@Override
		public void toMap(Map<String, Object> mapToFill) {
			for (final Attribute attr : attributes()) {
				try {
					mapToFill.put(attr.getName(), attr.getValue());
				} catch (Exception e) {
					//
				}
			}
		}

		@Override
		public void toJson(JsonBuffer buffer) {
			for (final Attribute attr : attributes()) {
				attr.toJson(buffer);
			}
		}

	} /* class RecordAttributeProvider */

}
