/* $Id$
 * 
 * Copyright (C) 2007-09 Stephane GALLAND.
 * Copyright (C) 2011-12 Stephane GALLAND.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 * This program is free software; you can redistribute it and/or modify
 */
package org.arakhne.util.ref;

import java.awt.geom.Point2D;
import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Map.Entry;

import org.arakhne.afc.math.MathConstants;
import org.arakhne.afc.math.continous.object2d.Point2f;
import org.arakhne.afc.math.continous.object2d.Tuple2f;
import org.arakhne.afc.math.continous.object2d.Vector2f;
import org.arakhne.afc.math.continous.object3d.Point3f;
import org.arakhne.afc.math.continous.object3d.Quaternion;
import org.arakhne.afc.math.continous.object3d.Tuple3f;
import org.arakhne.afc.math.continous.object3d.Vector3f;
import org.arakhne.afc.math.continous.object4d.AxisAngle4f;
import org.arakhne.afc.math.generic.Tuple2D;

import junit.framework.AssertionFailedError;
import junit.framework.TestCase;

/** Test case with utility functions.
 *
 * @author $Author: galland$
 * @author $Author: cbohrhauer$
 * @version $FullVersion$
 * @mavengroupid org.arakhne.afc
 * @mavenartifactid arakhneRefs
 */
public abstract class AbstractTestCase extends TestCase {
	
	/** Precision of the floating point number epsilon-tests.
	 */
	protected final static int DEFAULT_DECIMAL_COUNT = 8;

	/** Default random number generator.
	 */
	protected final Random RANDOM = new Random();
	
	/**
	 * Minimal count of points generated by {@link #randomTuples3D()}.
	 */
	protected static final int MIN_POINT_COUNT = 100;

	/**
	 * Maximal count of points generated by {@link #randomTuples3D()}.
	 */
	protected static final int MAX_POINT_COUNT = 1000;
	
	/**
	 * Minimal count of vectors generated by {@link #randomVectors3D()}.
	 */
	protected static final int MIN_VECTOR_COUNT = 100;

	/**
	 * Maximal count of vectors generated by {@link #randomVectors3D()}.
	 */
	protected static final int MAX_VECTOR_COUNT = 1000;

	/**
	 * Size of the world.
	 */
	protected static final int WORLD_SIZE = 1000;

	/**
	 * Maximal distance between points
	 */
	protected static final int DELTA_SIZE = 100;
	
	private int decimalPrecision = DEFAULT_DECIMAL_COUNT;

	/** Set the epsilon used ben testing floating-point values.
	 * 
	 * @param precision is the count of decimal digits to support
	 */
	protected void setDecimalPrecision(int precision) {
		this.decimalPrecision = Math.max(0, precision);
	}
	
	/** Set the epsilon used ben testing floating-point values to
	 * its default value.
	 */
	protected void setDefaultDecimalPrecision() {
		this.decimalPrecision = DEFAULT_DECIMAL_COUNT;
	}
		
	private static String arrayToString(Object o) {
		if (o==null) return null;
		if (o instanceof boolean[])
			return Arrays.toString((boolean[])o);
		if (o instanceof byte[])
			return Arrays.toString((byte[])o);
		if (o instanceof char[])
			return Arrays.toString((char[])o);
		if (o instanceof short[])
			return Arrays.toString((short[])o);
		if (o instanceof int[])
			return Arrays.toString((int[])o);
		if (o instanceof long[])
			return Arrays.toString((long[])o);
		if (o instanceof float[])
			return Arrays.toString((float[])o);
		if (o instanceof double[])
			return Arrays.toString((double[])o);
		if (o instanceof Object[])
			return Arrays.toString((Object[])o);
		return o.toString();
	}

	/** Replies if the given elements is in the array.
	 * <p>
	 * This function is based on {@link Object#equals(java.lang.Object)}.
	 */
	private static <T> boolean arrayContainsAll(T[] elts, T[] array) {
		boolean found;
		for (T elt : elts) {
			found = false;
			for (T t : array) {
				if ((t==elt)||
					((t!=null)&&(t.equals(elt)))) {
					found = true;
					break;
				}
			}
			if (!found) return false;
		}
		return true;
	}

	/**
	 * Format a failure message for invalid value.
	 * 
	 * @param message is the message to reply.
	 * @param expected is the expected object.
	 * @param actual is the actual value of the object.
	 * @return the message
	 */
	protected static String formatFailMessage(String message, Object expected, Object actual) {
		StringBuilder formatted = new StringBuilder();
		if (message!=null) {
			formatted.append(message);
			formatted.append(' ');
		}
		formatted.append("expected:<"); //$NON-NLS-1$
		formatted.append(arrayToString(expected));
		formatted.append("> but was:<"); //$NON-NLS-1$
		formatted.append(arrayToString(actual));
		formatted.append(">"); //$NON-NLS-1$
		return formatted.toString();
	}

	/**
	 * Format a failure message for invalid value.
	 * 
	 * @param message is the first part of the message (optional).
	 * @param msg is the second part of the message (mandatory).
	 * @param actual is the actual value of the object.
	 * @return the message
	 */
	protected static String formatFailMessage(String message, String msg, Object actual) {
		StringBuilder formatted = new StringBuilder();
		if (message!=null) {
			formatted.append(message);
			formatted.append(' ');
		}
		formatted.append(msg);
		formatted.append(" but was:<"); //$NON-NLS-1$
		formatted.append(arrayToString(actual));
		formatted.append(">"); //$NON-NLS-1$
		return formatted.toString();
	}

	/**
	 * Format a failure message for not-expected values.
	 * 
	 * @param message is the message to reply.
	 * @param notexpected is the not-expected object.
	 * @return the message
	 */
	protected static String formatFailNegMessage(String message, Object notexpected) {
		StringBuilder formatted = new StringBuilder();
		if (message!=null) {
			formatted.append(message);
			formatted.append(' ');
		}
		formatted.append("not expected:<"); //$NON-NLS-1$
		formatted.append(arrayToString(notexpected));
		formatted.append("> but the same"); //$NON-NLS-1$
		return formatted.toString();
	}

	/** Asserts that two objects are not equal. If they are
	 * an AssertionFailedError is thrown with the given message.
	 * 
	 * @param message is the error message to put inside the assertion.
	 * @param notexpected is the value which is not expected by the unit test.
	 * @param actual is the actual value of the object in the unit test.
	 */
	protected static void assertNotEquals(String message, Object notexpected, Object actual) {
		if ((notexpected!=actual)&&
			((notexpected==null)
			 ||
			 (!notexpected.equals(actual)))) return;
		fail(formatFailNegMessage(message, notexpected));
	}

	/** Asserts that two objects are not equal. If they are
	 * an AssertionFailedError is thrown with the given message.
	 * 
	 * @param notexpected is the value which is not expected by the unit test.
	 * @param actual is the actual value of the object in the unit test.
	 */
	protected static void assertNotEquals(Object notexpected, Object actual) {
	    assertNotEquals(null, notexpected, actual);
	}
	
	/** Asserts that the actuel object is equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown with the given message.
	 * 
	 * @param message is the error message to put inside the assertion.
	 * @param expectedObjects are the set of expected values during the unit test.
	 * @param actual is the actual value of the object in the unit test.
	 */
	protected static void assertEquals(String message, Object[] expectedObjects, Object actual) {
		if ((expectedObjects!=null)&&(expectedObjects.length>0)) {
			for (Object object : expectedObjects) {
				if ((object==null)&&(actual==null)) return;
				if ((object!=null)&&(object.equals(actual))) return;
			}
		}
		fail(formatFailMessage(message, expectedObjects, actual));
	}

	/** Asserts that the actuel object is equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown.
	 * 
	 * @param expectedObjects are the set of expected values during the unit test.
	 * @param actual is the actual value of the object in the unit test.
	 */
	protected static void assertEquals(Object[] expectedObjects, Object actual) {
	    assertEquals(null, expectedObjects, actual);
	}

	/** Asserts that the actuel object is equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown with the given message.
	 *
	 * @param <T> is the type of the array.
	 * @param message is the error message to put inside the assertion.
	 * @param expectedObjects are the set of expected values during the unit test.
	 * @param actual is the actual value of the objects in the unit test.
	 */
	protected static <T> void assertEquals(String message, T[] expectedObjects, T[] actual) {
		if (expectedObjects==actual) return;
		if ((expectedObjects!=null)&&(actual!=null)&&
			(expectedObjects.length==actual.length)) {
			boolean ok = true;
			for(int i=0; i<expectedObjects.length; i++) {
				if ((expectedObjects[i]!=null)||(actual[i]!=null)) {
					if ((expectedObjects[i]==null)||(!expectedObjects[i].equals(actual[i]))) {
						ok = false;
						break;
					}
				}
			}
			if (ok) return;
		}
		fail(formatFailMessage(message, expectedObjects, actual));
	}

	/** Asserts that the actuel object is equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown.
	 *
	 * @param <T> is the type of the array.
	 * @param expectedObjects are the set of expected values during the unit test.
	 * @param actual is the actual value of the objects in the unit test.
	 */
	protected static <T> void assertEquals(T[] expectedObjects, T[] actual) {
	    assertEquals(null, expectedObjects, actual);
	}

	/** Asserts that the actuel object is not equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown with the given message.
	 *
	 * @param <T> is the type of the array.
	 * @param message is the error message to put inside the assertion.
	 * @param expectedObjects are the set of expected values during the unit test.
	 * @param actual is the actual value of the objects in the unit test.
	 */
	protected static <T> void assertNotEquals(String message, T[] expectedObjects, T[] actual) {
		if (expectedObjects!=actual) {			
			if ((expectedObjects!=null)&&(actual!=null)) {
				if (expectedObjects.length!=actual.length) return;
				boolean ok = true;
				for(int i=0; i<expectedObjects.length; i++) {
					if ((expectedObjects[i]!=null)||(actual[i]!=null)) {
						if ((expectedObjects[i]==null)||(!expectedObjects[i].equals(actual[i]))) {
							ok = false;
							break;
						}
					}
				}
				if (!ok) return;
			}
			else return;
		}
		fail(formatFailMessage(message, expectedObjects, actual));
	}

	/** Asserts that the actuel object is not equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown.
	 *
	 * @param <T> is the type of the array.
	 * @param expectedObjects are the set of expected values during the unit test.
	 * @param actual is the actual value of the objects in the unit test.
	 */
	protected static <T> void assertNotEquals(T[] expectedObjects, T[] actual) {
	    assertNotEquals(null, expectedObjects, actual);
	}

	/** Asserts that the actuel object is equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown.
	 * This assertion function tests the types of its parameters to call the best
	 * {@code assertEquals} function.
	 * 
	 * @param expected is the expected value during the unit test.
	 * @param actual is the actual value of the object during the unit test.
	 * @see #assertEquals(Object, Object)
	 * @see #assertEquals(Object[], Object)
	 * @see #assertEquals(Object[], Object[])
	 */
	protected static void assertEqualsGeneric(Object expected, Object actual) {
		assertEqualsGeneric(null, expected, actual);
	}

	/** Asserts that the actuel object is equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown.
	 * This assertion function tests the types of its parameters to call the best
	 * {@code assertEquals} function.
	 * 
	 * @param message is the error message to put inside the assertion.
	 * @param expected is the expected value during the unit test.
	 * @param actual is the actual value of the object during the unit test.
	 * @see #assertEquals(Object, Object)
	 * @see #assertEquals(Object[], Object)
	 * @see #assertEquals(Object[], Object[])
	 */
	protected static void assertEqualsGeneric(String message, Object expected, Object actual) {
		if ((expected!=null)&&(actual!=null)&&(expected.getClass().isArray())) {
			if (actual.getClass().isArray())
				assertEquals(message, (Object[])expected, (Object[])actual);
			else
				assertEquals(message, (Object[])expected, actual);
		}
		else assertEquals(message, expected, actual);
	}

	/** Asserts that the actuel similar is equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown.
	 * 
	 * @param <T> is the type of the values
	 * @param expectedObjects are the expected values during the unit test.
	 * @param actual are the actual values of the objects during the unit test.
	 */
	protected static <T> void assertSimilars(T[] expectedObjects, T[] actual) {
	    assertSimilars(null, expectedObjects, actual);
	}

	/** Asserts that the actuel similar is equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown.
	 * 
	 * @param <T> is the type of the values
	 * @param message is the error message to put inside the assertion.
	 * @param expectedObjects are the expected values during the unit test.
	 * @param actual are the actual values of the objects during the unit test.
	 */
	protected static <T> void assertSimilars(String message, T[] expectedObjects, T[] actual) {
		if (expectedObjects==actual) return;
		if ((arrayContainsAll(expectedObjects, actual))&&(arrayContainsAll(actual, expectedObjects)))
			return;
		fail(formatFailMessage(message, expectedObjects, actual));
	}

	/** Asserts that the actuel similar is equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown.
	 * 
	 * @param <T> is the type of the values
	 * @param expectedObjects are the expected values during the unit test.
	 * @param actual are the actual values of the objects during the unit test.
	 */
	protected static <T> void assertSimilars(Collection<T> expectedObjects, Collection<T> actual) {
	    assertSimilars(null, expectedObjects, actual);
	}
	
	/** Asserts that the actuel similar is equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown.
	 * 
	 * @param <T> is the type of the values
	 * @param message is the error message to put inside the assertion.
	 * @param expectedObjects are the expected values during the unit test.
	 * @param actual are the actual values of the objects during the unit test.
	 */
	protected static <T> void assertSimilars(String message, Collection<T> expectedObjects, Collection<T> actual) {
		if (expectedObjects==actual) return;
		if (similars(expectedObjects,actual)) return;
		fail(formatFailMessage(message, expectedObjects, actual));
	}
	
	private static <T> boolean similars(Collection<T> c1, Collection<T> c2) {
		ArrayList<T> a = new ArrayList<T>();
		a.addAll(c2);
		for(T elt : c1) {
			if (!a.remove(elt)) {
				return false;
			}
		}
		return a.isEmpty();
	}

	/** Asserts that the actuel similar is equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown.
	 * 
	 * @param <T> is the type of the values
	 * @param expectedObjects are the expected values during the unit test.
	 * @param actual are the actual values of the objects during the unit test.
	 */
	protected static <T> void assertEquals(List<T> expectedObjects, List<T> actual) {
	    assertEquals(null, expectedObjects, actual);
	}
	
	/** Asserts that the actuel similar is equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown.
	 * 
	 * @param <T> is the type of the values.
	 * @param message is the error message to put inside the assertion.
	 * @param expectedObjects are the expected values during the unit test.
	 * @param actual are the actual values of the objects during the unit test.
	 */
	protected static <T> void assertEquals(String message, List<T> expectedObjects, List<T> actual) {
		if (expectedObjects==actual) return;
		if (equals(expectedObjects,actual)) return;
		fail(formatFailMessage(message, expectedObjects, actual));
	}

	private static <T> boolean equals(List<T> c1, List<T> c2) {
		if (c1.size()!=c2.size()) return false;
		int count = c1.size();
		T e1, e2;
		for(int i=0; i<count; i++) {
			e1 = c1.get(i);
			e2 = c2.get(i);
			if ((e1!=e2)&&(!e1.equals(e2))) {
				return false;
			}
		}
		return true;
	}
	
	/** Asserts that the actuel similar is not equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown.
	 * 
	 * @param <T> is the type of the values
	 * @param expectedObjects are the expected values during the unit test.
	 * @param actual are the actual values of the objects during the unit test.
	 */
	protected static <T> void assertNotEquals(List<T> expectedObjects, List<T> actual) {
	    assertNotEquals(null, expectedObjects, actual);
	}
	
	/** Asserts that the actuel object is not equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown.
	 * 
	 * @param <T> is the type of the values
	 * @param message is the error message to put inside the assertion.
	 * @param expectedObjects are the expected values during the unit test.
	 * @param actual are the actual values of the objects during the unit test.
	 */
	protected static <T> void assertNotEquals(String message, List<T> expectedObjects, List<T> actual) {
		if ((expectedObjects!=actual)&&(!equals(expectedObjects,actual))) return;
		fail(formatFailMessage(message, expectedObjects, actual));
	}

	/** Asserts that the actual object is equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown.
	 * 
	 * @param <T> is the type of the values
	 * @param <X> is the element's type of the values if they are arrays.
	 * @param message is the error message to put inside the assertion.
	 * @param expected is the expected value during the unit test.
	 * @param actual are the actual value of the object during the unit test.
	 */
	@SuppressWarnings("unchecked")
	protected static <T, X> void assertSimilars(String message, T expected, T actual) {
		if (expected==actual) return;
		if (expected instanceof Collection)
			assertSimilars(message, (Collection<?>)expected, (Collection<?>)actual);
		else if (expected instanceof Point2D)
			assertSimilars(message, (Point2D)expected, (Point2D)actual);
		else if (expected instanceof Date)
			assertSimilars(message, (Date)expected, (Date)actual);
		else if (expected.getClass().isArray())
			assertSimilars(message, (X[])expected, (X[])actual);
		else
			assertEquals(message, expected, actual);
	}

	/** Asserts that the actual object is equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown.
	 * 
	 * @param <T> is the type of the values.
	 * @param <X> is the element's type of the values if they are arrays.
	 * @param message is the error message to put inside the assertion.
	 * @param expected is the expected value.
	 * @param actual is the current value.
	 */
	protected static <T, X> void assertNotSimilars(String message, T expected, T actual) {
		if (expected!=actual) {
			try {
				assertSimilars(message,expected, actual);
			}
			catch(AssertionError _) {
				// ok
				return;
			}
			catch(AssertionFailedError _) {
				// ok
				return;
			}
		}		
		fail(formatFailMessage(message, expected, actual));
	}

	/** Replies if the two objects are similars.
	 * 
	 * @param <T> is the type of the values
	 * @param <X> is the element's type of the values if they are arrays.
	 * @param obj1
	 * @param obj2
	 * @return <code>true</code> if the objects are similar, otherwise <code>false</code>
	 */
	protected static <T, X> boolean isSimilarObjects(T obj1, T obj2) {
		if (obj1==obj2) return true;
		try {
			assertSimilars(null,obj1, obj2);
			return true;
		}
		catch(AssertionError _) {
			return false;
		}
		catch(AssertionFailedError _) {
			return false;
		}
	}

	/** Asserts that the actuel similar is equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown.
	 * 
	 * @param <K> is the type of the map keys.
	 * @param <V> is the type of the map values.
	 * @param expectedObjects is the expected map.
	 * @param actual is the current map.
	 */
	protected static <K,V> void assertDeepSimilars(Map<K,V> expectedObjects, Map<K,V> actual) {
	    assertDeepSimilars(null, expectedObjects, actual);
	}
	
	/** Asserts that the actuel similar is equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown.
	 * 
	 * @param <K> is the type of the map keys.
	 * @param <V> is the type of the map values.
	 * @param message is the error message to put inside the assertion.
	 * @param expectedObjects is the expected map.
	 * @param actual is the current map.
	 */
	protected static <K,V> void assertDeepSimilars(String message, Map<K,V> expectedObjects, Map<K,V> actual) {
		if (expectedObjects==actual) return;
		if (similars(expectedObjects.keySet(), actual.keySet())) {
			for(Entry<K,V> entry : expectedObjects.entrySet()) {
				V v1 = entry.getValue();
				V v2 = actual.get(entry.getKey());
				assertSimilars(message, v1, v2);
			}
			// all values are correct
			return;
		}
		fail(formatFailMessage(message, expectedObjects, actual));
	}

	/** Asserts that the actuel similar is equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown.
	 * 
	 * @param <K> is the type of the map keys.
	 * @param <V> is the type of the map values.
	 * @param expectedObjects is the expected map.
	 * @param actual is the current map.
	 */
	protected static <K,V> void assertNotDeepSimilars(Map<K,V> expectedObjects, Map<K,V> actual) {
	    assertNotDeepSimilars(null, expectedObjects, actual);
	}
	
	/** Asserts that the actuel similar is equal to one of the expected objects. If not
	 * an AssertionFailedError is thrown.
	 * 
	 * @param <K> is the type of the map keys.
	 * @param <V> is the type of the map values.
	 * @param message is the error message to put inside the assertion.
	 * @param expectedObjects is the expected map.
	 * @param actual is the current map.
	 */
	protected static <K,V> void assertNotDeepSimilars(String message, Map<K,V> expectedObjects, Map<K,V> actual) {
		if (expectedObjects!=actual) {
			if (!similars(expectedObjects.keySet(), actual.keySet())) return;
			
			for(Entry<K,V> entry : expectedObjects.entrySet()) {
				V v1 = entry.getValue();
				V v2 = actual.get(entry.getKey());
				if (!isSimilarObjects(v1, v2)) return;
			}
		}
		fail(formatFailMessage(message, expectedObjects, actual));
	}

	/** Asserts that the specified value is stricly negative.
	 * 
	 * @param number
	 */
	protected static void assertStrictlyNegative(Number number) {
		assertStrictlyNegative(null,number);
	}

	/** Asserts that the specified value is stricly negative.
	 * 
	 * @param message is the error message to put inside the assertion.
	 * @param number
	 */
	protected static void assertStrictlyNegative(String message, Number number) {
		if (number.doubleValue()<0.) return;
		fail(formatFailMessage(message, "expected negative value", number)); //$NON-NLS-1$
	}

	/** Asserts that the specified value is stricly positive.
	 * 
	 * @param number
	 */
	protected static void assertStrictlyPositive(Number number) {
		assertStrictlyPositive(null,number);
	}

	/** Asserts that the specified value is stricly positive.
	 * 
	 * @param message is the error message to put inside the assertion.
	 * @param number
	 */
	protected static void assertStrictlyPositive(String message, Number number) {
		if (number.doubleValue()>0.) return;
		fail(formatFailMessage(message, "expected positive value", number)); //$NON-NLS-1$
	}

	/** Asserts that the specified value is negative.
	 * 
	 * @param number
	 */
	protected static void assertNegative(Number number) {
		assertNegative(null,number);
	}

	/** Asserts that the specified value is negative.
	 * 
	 * @param message is the error message to put inside the assertion.
	 * @param number
	 */
	protected static void assertNegative(String message, Number number) {
		if (number.doubleValue()<=0.) return;
		fail(formatFailMessage(message, "expected negative value", number)); //$NON-NLS-1$
	}

	/** Asserts that the specified value is positive.
	 * 
	 * @param number
	 */
	protected static void assertPositive(Number number) {
		assertPositive(null,number);
	}

	/** Asserts that the specified value is positive.
	 * 
	 * @param message is the error message to put inside the assertion.
	 * @param number
	 */
	protected static void assertPositive(String message, Number number) {
		if (number.doubleValue()>=0.) return;
		fail(formatFailMessage(message, "expected positive value", number)); //$NON-NLS-1$
	}

	/**
	 * Replies an array which is containing values randomly selected from the parameter.
	 * Duplicate values are allowed.
	 * 
	 * @param <T> is the type of the values.
	 * @param availableValues is the collection of available values.
	 * @return the selected values (possible duplicated)
	 */
	@SuppressWarnings("unchecked")
	protected static <T> T[] extractRandomValues(T[] availableValues) {
		Random rnd = new Random();
		int count = rnd.nextInt(500);
		ArrayList<T> tab = new ArrayList<T>(count);
		for(int i=0; i<count; i++) {
			tab.add(availableValues[rnd.nextInt(availableValues.length)]);
		}
		Class<?> clazz = availableValues.getClass().getComponentType();
		T[] array = (T[])Array.newInstance(clazz, tab.size());
		tab.toArray(array);
		tab.clear();
		return array;
	}
	
	/** Replies a randomized string.
	 * 
	 * @return a random string.
	 */
	protected static String randomString() {
		return randomString(-1);
	}

	/** Replies a randomized string with a max length.
	 *
	 * @param maxSize is the max length of the string.
	 * @return a random string with a max length.
	 */
	protected static String randomString(int maxSize) {
		Random rnd = new Random();
		StringBuilder b = new StringBuilder();
		int count = rnd.nextInt(maxSize<=0 ? 255 : maxSize-1)+1;
		for(int i=0; i<count; i++) {
			char c = (char)('A' + rnd.nextInt(26));
			b.append(c);
		}
		return b.toString();
	}

	/** Assert the the specified method thrown an exception
	 * 
	 * @param self is the calling object
	 * @param method is the name of the method to invoke
	 * @param types is the parameter types of the method
	 * @param parameters is the parameter values to pass at invocation.
	 */
	protected static void assertException(Object self, String method, Class<?>[] types, Object[] parameters) {
		assertException(null, self, method, types, parameters);
	}

	/** Assert the the specified method thrown an exception
	 * 
	 * @param message is the error message to put in the assertion.
	 * @param self is the calling object
	 * @param method is the name of the method to invoke
	 * @param types is the parameter types of the method
	 * @param parameters is the parameter values to pass at invocation.
	 */
	protected static void assertException(String message, Object self, String method, Class<?>[] types, Object[] parameters) {
		try {
			Class<?> clazz = self.getClass();
			Method methodFunc = clazz.getMethod(method, types);
			methodFunc.invoke(self, parameters);
			fail((message==null ? "" : message)+"An exception was attempted but never thrown."); //$NON-NLS-1$ //$NON-NLS-2$
		}
		catch(Exception _) {
			// Expected behavior
		}
	}

	/** Assert the the specified method thrown an exception
	 * 
	 * @param self is the calling object
	 * @param method is the name of the method to invoke
	 */
	protected static void assertException(Object self, String method) {
		assertException(null, self, method, new Class<?>[0], new Object[0]);
	}

	/** Assert the the specified method thrown an exception
	 * 
	 * @param message is the error message to put in the assertion.
	 * @param self is the calling object
	 * @param method is the name of the method to invoke
	 */
	protected static void assertException(String message, Object self, String method) {
		assertException(message, self, method, new Class<?>[0], new Object[0]);
	}

	/** Test if the two collections contain the same elements without
	 * taking into account the order of the elements in the collections.
	 * 
	 * @param <T>
	 * @param expected
	 * @param actual
	 */
	protected static <T> void assertEpsilonEquals(Collection<? extends T> expected, Collection<? extends T> actual) {
		assertEpsilonEquals(null, expected, actual);
	}

	/** Test if the two collections contain the same elements without
	 * taking into account the order of the elements in the collections.
	 *
	 * @param <T>
	 * @param message
	 * @param expected
	 * @param actual
	 */
	protected static <T> void assertEpsilonEquals(String message, Collection<? extends T> expected, Collection<? extends T> actual) {
		ArrayList<T> l = new ArrayList<T>(actual);
		for(T e : expected) {
			if (!l.remove(e)) {
				fail((message==null ? "" : (message+": "))  //$NON-NLS-1$//$NON-NLS-2$
						+"not similar collections, expected element:"+ //$NON-NLS-1$
						expected);
			}
		}
		if (!l.isEmpty()) {
			fail((message==null ? "" : (message+": "))  //$NON-NLS-1$//$NON-NLS-2$
					+"not similar collections, not expected elements:"+ //$NON-NLS-1$
					l);
		}
	}

	/** Test if the two collections contain the same elements without
	 * taking into account the order of the elements in the collections.
	 * 
	 * @param <T>
	 * @param expected
	 * @param actual
	 */
	protected static <T> void assertEpsilonEquals(T[] expected, T[] actual) {
		assertEpsilonEquals(null, expected, actual);
	}

	/** Test if the two collections contain the same elements without
	 * taking into account the order of the elements in the collections.
	 *
	 * @param <T>
	 * @param message
	 * @param expected
	 * @param actual
	 */
	protected static <T> void assertEpsilonEquals(String message, T[] expected, T[] actual) {
		ArrayList<T> l = new ArrayList<T>(Arrays.asList(actual));
		for(T e : expected) {
			if (!l.remove(e)) {
				fail((message==null ? "" : (message+": "))  //$NON-NLS-1$//$NON-NLS-2$
						+"not similar collections, expected element:"+ //$NON-NLS-1$
						expected.toString());
			}
		}
		if (!l.isEmpty()) {
			fail((message==null ? "" : (message+": "))  //$NON-NLS-1$//$NON-NLS-2$
					+"not similar collections, not expected elements:"+ //$NON-NLS-1$
					l.toString());
		}
	}

	/** Test if the two collections do no contain the same elements without
	 * taking into account the order of the elements in the collections.
	 * 
	 * @param <T>
	 * @param expected
	 * @param actual
	 */
	protected static <T> void assertNotEpsilonEquals(T[] expected, T[] actual) {
		assertNotEpsilonEquals(null, expected, actual);
	}

	/** Test if the two collections do no contain the same elements without
	 * taking into account the order of the elements in the collections.
	 * 
	 * @param <T>
	 * @param message
	 * @param expected
	 * @param actual
	 */
	protected static <T> void assertNotEpsilonEquals(String message, T[] expected, T[] actual) {
		ArrayList<T> l = new ArrayList<T>(Arrays.asList(actual));
		for(T e : expected) {
			if (!l.remove(e)) return;
		}
		if (l.isEmpty()) {
			fail((message==null ? "" : (message+": "))  //$NON-NLS-1$//$NON-NLS-2$
					+"similar collections when not attempted"); //$NON-NLS-1$
		}
	}

	
	/** Test if the actual element is equals to the expected value at epsilon.
	 * 
	 * @param expected
	 * @param actual
	 */
	protected void assertEpsilonEquals(Tuple3f<?> expected, Tuple3f<?> actual) {
		assertEpsilonEquals(null, expected, actual);
	}

	/** Test if the actual element is equals to the expected value at epsilon.
	 * 
	 * @param message
	 * @param expected
	 * @param actual
	 */
	protected void assertEpsilonEquals(String message, Tuple3f<?> expected, Tuple3f<?> actual) {
		String msg = message;
		if (msg!=null) {
			msg += "; "; //$NON-NLS-1$
		}
		else {
			msg = ""; //$NON-NLS-1$
		}
		assertEpsilonEquals(msg+"x coordinate", expected.getX(), actual.getX()); //$NON-NLS-1$
		assertEpsilonEquals(msg+"y coordinate", expected.getY(), actual.getY()); //$NON-NLS-1$
		assertEpsilonEquals(msg+"z coordinate", expected.getZ(), actual.getZ()); //$NON-NLS-1$
	}
	
	/** Test if the actual element is equals to the expected value at epsilon.
	 * 
	 * @param expected
	 * @param actual
	 */
	protected void assertEpsilonEquals(AxisAngle4f expected, AxisAngle4f actual) {
		assertEpsilonEquals(null, expected, actual);
	}

	/** Test if the actual element is equals to the expected value at epsilon.
	 * 
	 * @param message
	 * @param expected
	 * @param actual
	 */
	protected void assertEpsilonEquals(String message, AxisAngle4f expected, AxisAngle4f actual) {
		float length1 = (float) Math.sqrt(expected.getX()*expected.getX()+expected.getY()*expected.getY()+expected.getZ()*expected.getZ());
		float length2 = (float) Math.sqrt(actual.getX()*actual.getX()+actual.getY()*actual.getY()+actual.getZ()*actual.getZ());
		String msg = message;
		if (msg!=null) {
			msg += "; "; //$NON-NLS-1$
		}
		else {
			msg = ""; //$NON-NLS-1$
		}
		assertEpsilonEquals(msg+", x coordinate", expected.getX()/length1, actual.getX()/length2); //$NON-NLS-1$
		assertEpsilonEquals(msg+", y coordinate", expected.getY()/length1, actual.getY()/length2); //$NON-NLS-1$
		assertEpsilonEquals(msg+", z coordinate", expected.getZ()/length1, actual.getZ()/length2); //$NON-NLS-1$
		assertEpsilonEquals(msg+", angle", expected.angle, actual.angle); //$NON-NLS-1$
	}
	
	/** Test if the actual element is equals to the expected value at epsilon.
	 * 
	 * @param expected
	 * @param actual
	 */
	protected void assertEpsilonEquals(Tuple2D expected, Tuple2D actual) {
		assertEpsilonEquals(null, expected, actual);
	}
	
	/** Test if the actual element is equals to the expected value at epsilon.
	 * 
	 * @param message
	 * @param expected
	 * @param actual
	 */
	protected void assertEpsilonEquals(String message, Tuple2D expected, Tuple2D actual) {
		assertEpsilonEquals(message, expected.getX(), actual.getX());
		assertEpsilonEquals(message, expected.getY(), actual.getY());
	}
	
	/** Test if the actual element is equals to the expected value at epsilon.
	 * 
	 * @param message
	 * @param expected
	 * @param actual
	 */
	protected void assertEpsilonEquals(String message, float expected, float actual) {
		if (isEpsilonEquals(expected,actual)) return;
		fail((message==null ? "" : (message+": "))  //$NON-NLS-1$//$NON-NLS-2$
				+"not same float value, expected:"+ //$NON-NLS-1$
				expected
				+", actual:"+actual); //$NON-NLS-1$
	}
	
	/** Test if the actual element is equals to the expected value at epsilon.
	 * 
	 * @param expected
	 * @param actual
	 */
	protected void assertEpsilonEquals(float expected, float actual) {
		assertEpsilonEquals(null, expected, actual);
	}

	/** Test if the two collections contain the same elements without
	 * taking into account the order of the elements in the collections.
	 * 
	 * @param expected
	 * @param actual
	 */
	protected void assertEpsilonEquals(float[] expected, float[] actual) {
		assertEpsilonEquals(null, expected, actual);
	}

	/** Test if the two collections contain the same elements without
	 * taking into account the order of the elements in the collections.
	 *
	 * @param message
	 * @param expected
	 * @param actual
	 */
	protected void assertEpsilonEquals(String message, float[] expected, float[] actual) {
		float[] l = new float[actual.length];
		int size = l.length;
		System.arraycopy(actual, 0, l, 0, l.length);
		for(float e : expected) {
			
			int index = -1;
			for(int i=0; i<size && index==-1; i++) {
				if (isEpsilonEquals(e, l[i]))
					index = i;
			}
			
			if (index==-1) {
				fail((message==null ? "" : (message+": "))  //$NON-NLS-1$//$NON-NLS-2$
						+"not similar collections, expected element:"+ //$NON-NLS-1$
						Arrays.toString(expected)+" inside "+Arrays.toString(actual)); //$NON-NLS-1$
			}
			else {
				System.arraycopy(l, index+1, l, index, size-index-1);
				size--;
			}
		}
		if (size>0) {
			fail((message==null ? "" : (message+": "))  //$NON-NLS-1$//$NON-NLS-2$
					+"not similar collections, not expected elements:"+ //$NON-NLS-1$
					l.toString());
		}
	}
	
	/** Test if the two collections contain the same elements without
	 * taking into account the order of the elements in the collections.
	 * 
	 * @param expected
	 * @param actual
	 */
	protected void assertEpsilonEquals(Quaternion expected, Quaternion actual) {
		assertEpsilonEquals(null, expected, actual);
	}
	
	/** Test if the actual element is equals to the expected value at epsilon.
	 * 
	 * @param message
	 * @param expected
	 * @param actual
	 */
	protected void assertEpsilonEquals(String message, Quaternion expected, Quaternion actual) {
		assertEpsilonEquals(message, expected.getX(), actual.getX());
		assertEpsilonEquals(message, expected.getY(), actual.getY());
		assertEpsilonEquals(message, expected.getZ(), actual.getZ());
		assertEpsilonEquals(message, expected.getW(), actual.getW());
	}

	/** Replies if two values are equals at espilon.
	 * 
	 * @param a
	 * @param b
	 * @return <code>true</code> or <code>false</code>
	 */
	protected boolean isEpsilonEquals(float a, float b) {
		if (Float.isInfinite(a) || Float.isInfinite(b)
			|| Float.isNaN(a) || Float.isNaN(b))
			return a==b;
		return isEpsilonEquals(new BigDecimal(a), new BigDecimal(b));
	}
	
	/** Replies if two values are equals at espilon.
	 * 
	 * @param a
	 * @param b
	 * @return <code>true</code> or <code>false</code>
	 */
	protected boolean isEpsilonEquals(BigDecimal a, BigDecimal b) {
		return isEpsilonEquals(a, b);
	}

	/** Replies if two values are equals at espilon.
	 * 
	 * @param a
	 * @param b
	 * @param precision is the number of decimal digits to test.
	 * @return <code>true</code> or <code>false</code>
	 */
	protected boolean isEpsilonEquals(BigDecimal a, BigDecimal b, int precision) {
		BigDecimal ma = a.movePointRight(precision);
		BigDecimal mb = b.movePointRight(precision);
		BigDecimal aa = ma.setScale(0,BigDecimal.ROUND_HALF_UP);
		BigDecimal bb = mb.setScale(0,BigDecimal.ROUND_HALF_UP);
		if (aa.compareTo(bb)==0) return true;
		aa = ma.setScale(0,BigDecimal.ROUND_DOWN);
		bb = mb.setScale(0,BigDecimal.ROUND_DOWN);
		return (aa.compareTo(bb)==0);
	}
	
	

	/** Create a set of points.
	 * @return the points
	 */
	protected Tuple3f[] randomTuples3D() {
		return randomPoints3D();
	}

	/** Create a set of points.
	 * @return the points
	 */
	protected Tuple3f[] randomTuples3F() {
		return randomPoints3F();
	}

	/** Create a set of points.
	 * @return the points
	 */
	protected Tuple2f[] randomTuples2D() {
		return randomPoints2D();
	}

	/** Create a set of points.
	 * @return the points
	 */
	protected Tuple2f[] randomTuples2F() {
		return randomPoints2F();
	}

	/** Create a set of points.
	 * @return the points
	 */
	protected Point3f[] randomPoints3D() {
		int count = this.RANDOM.nextInt(MAX_POINT_COUNT);
		if (count<MIN_POINT_COUNT) count = MIN_POINT_COUNT;
		Point3f[] points = new Point3f[count];
		float x,y,z;
		Tuple3f<?> firstPts = null;
		for(int idx=0; idx<count; idx++) {
			if (firstPts==null) {
				x = this.RANDOM.nextFloat()*WORLD_SIZE;
				y = this.RANDOM.nextFloat()*WORLD_SIZE;
				z = this.RANDOM.nextFloat()*WORLD_SIZE;
				points[idx] = new Point3f(x,y,z);
				firstPts = points[idx]; 
			}
			else {
				x = firstPts.getX() + (this.RANDOM.nextFloat() - this.RANDOM.nextFloat())*DELTA_SIZE;
				y = firstPts.getY() + (this.RANDOM.nextFloat() - this.RANDOM.nextFloat())*DELTA_SIZE;
				z = firstPts.getZ() + (this.RANDOM.nextFloat() - this.RANDOM.nextFloat())*DELTA_SIZE;
				points[idx] = new Point3f(x,y,z);
			}
		}
		return points;
	}

	/** Create a set of points.
	 * @return the points
	 */
	protected Point3f[] randomPoints3F() {
		int count = this.RANDOM.nextInt(MAX_POINT_COUNT);
		if (count<MIN_POINT_COUNT) count = MIN_POINT_COUNT;
		Point3f[] points = new Point3f[count];
		float x,y,z;
		Tuple3f<?> firstPts = null;
		for(int idx=0; idx<count; idx++) {
			if (firstPts==null) {
				x = this.RANDOM.nextFloat()*WORLD_SIZE;
				y = this.RANDOM.nextFloat()*WORLD_SIZE;
				z = this.RANDOM.nextFloat()*WORLD_SIZE;
				points[idx] = new Point3f(x,y,z);
				firstPts = points[idx]; 
			}
			else {
				x = firstPts.getX() + (this.RANDOM.nextFloat() - this.RANDOM.nextFloat())*DELTA_SIZE;
				y = firstPts.getY() + (this.RANDOM.nextFloat() - this.RANDOM.nextFloat())*DELTA_SIZE;
				z = firstPts.getZ() + (this.RANDOM.nextFloat() - this.RANDOM.nextFloat())*DELTA_SIZE;
				points[idx] = new Point3f(x,y,z);
			}
		}
		return points;
	}

	/** Create a set of points.
	 * @return the points
	 */
	protected Point2f[] randomPoints2D() {
		int count = this.RANDOM.nextInt(MAX_POINT_COUNT);
		if (count<MIN_POINT_COUNT) count = MIN_POINT_COUNT;
		Point2f[] points = new Point2f[count];
		float x,y;
		Tuple2f<?> firstPts = null;
		for(int idx=0; idx<count; idx++) {
			if (firstPts==null) {
				x = this.RANDOM.nextFloat()*WORLD_SIZE;
				y = this.RANDOM.nextFloat()*WORLD_SIZE;
				points[idx] = new Point2f(x,y);
				firstPts = points[idx]; 
			}
			else {
				x = firstPts.getX() + (this.RANDOM.nextFloat() - this.RANDOM.nextFloat())*DELTA_SIZE;
				y = firstPts.getY() + (this.RANDOM.nextFloat() - this.RANDOM.nextFloat())*DELTA_SIZE;
				points[idx] = new Point2f(x,y);
			}
		}
		return points;
	}

	/** Create a set of points.
	 * @return the points
	 */
	protected Point2f[] randomPoints2F() {
		int count = this.RANDOM.nextInt(MAX_POINT_COUNT);
		if (count<MIN_POINT_COUNT) count = MIN_POINT_COUNT;
		Point2f[] points = new Point2f[count];
		float x,y;
		Tuple2f<?> firstPts = null;
		for(int idx=0; idx<count; idx++) {
			if (firstPts==null) {
				x = this.RANDOM.nextFloat()*WORLD_SIZE;
				y = this.RANDOM.nextFloat()*WORLD_SIZE;
				points[idx] = new Point2f(x,y);
				firstPts = points[idx]; 
			}
			else {
				x = firstPts.getX() + (this.RANDOM.nextFloat() - this.RANDOM.nextFloat())*DELTA_SIZE;
				y = firstPts.getY() + (this.RANDOM.nextFloat() - this.RANDOM.nextFloat())*DELTA_SIZE;
				points[idx] = new Point2f(x,y);
			}
		}
		return points;
	}

	/** Create a point.
	 * @return a point
	 */
	protected Point3f randomPoint3D() {
		float x = this.RANDOM.nextFloat()*WORLD_SIZE;
		float y = this.RANDOM.nextFloat()*WORLD_SIZE;
		float z = this.RANDOM.nextFloat()*WORLD_SIZE;
		return new Point3f(x,y,z);
	}

	/** Create a point.
	 * @return a point
	 */
	protected Point3f randomPoint3F() {
		float x = this.RANDOM.nextFloat()*WORLD_SIZE;
		float y = this.RANDOM.nextFloat()*WORLD_SIZE;
		float z = this.RANDOM.nextFloat()*WORLD_SIZE;
		return new Point3f(x,y,z);
	}

	/** Create a point.
	 * @return a point
	 */
	protected Point2f randomPoint2D() {
		float x = this.RANDOM.nextFloat()*WORLD_SIZE;
		float y = this.RANDOM.nextFloat()*WORLD_SIZE;
		return new Point2f(x,y);
	}

	/** Create a point.
	 * @return a point
	 */
	protected Point2f randomPoint2F() {
		float x = this.RANDOM.nextFloat()*WORLD_SIZE;
		float y = this.RANDOM.nextFloat()*WORLD_SIZE;
		return new Point2f(x,y);
	}

	/** Create a vector.
	 * @return a vector
	 */
	protected Vector3f randomVector3D() {
		float x = this.RANDOM.nextFloat()*WORLD_SIZE;
		float y = this.RANDOM.nextFloat()*WORLD_SIZE;
		float z = this.RANDOM.nextFloat()*WORLD_SIZE;
		Vector3f v = new Vector3f(x,y,z);
		v.normalize();
		return v;
	}

	/** Create a vector.
	 * @return a vector
	 */
	protected Vector3f randomVector3F() {
		float x = this.RANDOM.nextFloat()*WORLD_SIZE;
		float y = this.RANDOM.nextFloat()*WORLD_SIZE;
		float z = this.RANDOM.nextFloat()*WORLD_SIZE;
		Vector3f v = new Vector3f(x,y,z);
		v.normalize();
		return v;
	}

	/** Create a set of vectors.
	 * @return the vectors
	 * @since 4.1
	 */
	protected Vector3f[] randomVectors3F() {
		int count = this.RANDOM.nextInt(MAX_VECTOR_COUNT);
		if (count<MIN_VECTOR_COUNT) count = MIN_VECTOR_COUNT;
		Vector3f[] vectors = new Vector3f[count];
		float x,y,z;
		Tuple3f<?> firstVec = null;
		for(int idx=0; idx<count; idx++) {
			if (firstVec==null) {
				x = this.RANDOM.nextFloat()*WORLD_SIZE;
				y = this.RANDOM.nextFloat()*WORLD_SIZE;
				z = this.RANDOM.nextFloat()*WORLD_SIZE;
				vectors[idx] = new Vector3f(x,y,z);
				firstVec = vectors[idx]; 
			}
			else {
				x = firstVec.getX() + (this.RANDOM.nextFloat() - this.RANDOM.nextFloat())*DELTA_SIZE;
				y = firstVec.getY() + (this.RANDOM.nextFloat() - this.RANDOM.nextFloat())*DELTA_SIZE;
				z = firstVec.getZ() + (this.RANDOM.nextFloat() - this.RANDOM.nextFloat())*DELTA_SIZE;
				vectors[idx] = new Vector3f(x,y,z);
			}
		}
		return vectors;
	}

	/** Create a set of vectors.
	 * @return the vectors
	 * @since 4.1
	 */
	protected Vector3f[] randomVectors3D() {
		int count = this.RANDOM.nextInt(MAX_VECTOR_COUNT);
		if (count<MIN_VECTOR_COUNT) count = MIN_VECTOR_COUNT;
		Vector3f[] vectors = new Vector3f[count];
		float x,y,z;
		Tuple3f<?> firstVec = null;
		for(int idx=0; idx<count; idx++) {
			if (firstVec==null) {
				x = this.RANDOM.nextFloat()*WORLD_SIZE;
				y = this.RANDOM.nextFloat()*WORLD_SIZE;
				z = this.RANDOM.nextFloat()*WORLD_SIZE;
				vectors[idx] = new Vector3f(x,y,z);
				firstVec = vectors[idx]; 
			}
			else {
				x = firstVec.getX() + (this.RANDOM.nextFloat() - this.RANDOM.nextFloat())*DELTA_SIZE;
				y = firstVec.getY() + (this.RANDOM.nextFloat() - this.RANDOM.nextFloat())*DELTA_SIZE;
				z = firstVec.getZ() + (this.RANDOM.nextFloat() - this.RANDOM.nextFloat())*DELTA_SIZE;
				vectors[idx] = new Vector3f(x,y,z);
			}
		}
		return vectors;
	}

	/** Create a vector.
	 * @return a vector
	 */
	protected Vector2f randomVector2D() {
		float x = this.RANDOM.nextFloat()*WORLD_SIZE;
		float y = this.RANDOM.nextFloat()*WORLD_SIZE;
		Vector2f v = new Vector2f(x,y);
		v.normalize();
		return v;
	}

	/** Create a set of vectors.
	 * @return the vectors
	 * @since 4.1
	 */
	protected Vector2f[] randomVectors2D() {
		int count = this.RANDOM.nextInt(MAX_VECTOR_COUNT);
		if (count<MIN_VECTOR_COUNT) count = MIN_VECTOR_COUNT;
		Vector2f[] vectors = new Vector2f[count];
		float x,y;
		Tuple2f<?> firstVec = null;
		for(int idx=0; idx<count; idx++) {
			if (firstVec==null) {
				x = this.RANDOM.nextFloat()*WORLD_SIZE;
				y = this.RANDOM.nextFloat()*WORLD_SIZE;
				vectors[idx] = new Vector2f(x,y);
				firstVec = vectors[idx]; 
			}
			else {
				x = firstVec.getX() + (this.RANDOM.nextFloat() - this.RANDOM.nextFloat())*DELTA_SIZE;
				y = firstVec.getY() + (this.RANDOM.nextFloat() - this.RANDOM.nextFloat())*DELTA_SIZE;
				vectors[idx] = new Vector2f(x,y);
			}
		}
		return vectors;
	}

	/** Create a vector.
	 * @return a vector
	 */
	protected Vector2f randomVector2F() {
		float x = this.RANDOM.nextFloat()*WORLD_SIZE;
		float y = this.RANDOM.nextFloat()*WORLD_SIZE;
		Vector2f v = new Vector2f(x,y);
		v.normalize();
		return v;
	}

	/** Create a set of vectors.
	 * @return the vectors
	 * @since 4.1
	 */
	protected Vector2f[] randomVectors2F() {
		int count = this.RANDOM.nextInt(MAX_VECTOR_COUNT);
		if (count<MIN_VECTOR_COUNT) count = MIN_VECTOR_COUNT;
		Vector2f[] vectors = new Vector2f[count];
		float x,y;
		Tuple2f<?> firstVec = null;
		for(int idx=0; idx<count; idx++) {
			if (firstVec==null) {
				x = this.RANDOM.nextFloat()*WORLD_SIZE;
				y = this.RANDOM.nextFloat()*WORLD_SIZE;
				vectors[idx] = new Vector2f(x,y);
				firstVec = vectors[idx]; 
			}
			else {
				x = firstVec.getX() + (this.RANDOM.nextFloat() - this.RANDOM.nextFloat())*DELTA_SIZE;
				y = firstVec.getY() + (this.RANDOM.nextFloat() - this.RANDOM.nextFloat())*DELTA_SIZE;
				vectors[idx] = new Vector2f(x,y);
			}
		}
		return vectors;
	}

	/** Create an axis-angle.
	 * @return an axis-angle
	 */
	protected AxisAngle4f randomAxisAngle4f() {
		float x = this.RANDOM.nextFloat()*WORLD_SIZE;
		float y = this.RANDOM.nextFloat()*WORLD_SIZE;
		float z = this.RANDOM.nextFloat()*WORLD_SIZE;
		float a = this.RANDOM.nextFloat()*MathConstants.PI;
		return new AxisAngle4f(x,y,z,a);
	}

	/** Create a quaternion.
	 * @return a quaternion.
	 */
	protected Quaternion randomQuaternion() {
		float x = this.RANDOM.nextFloat()*WORLD_SIZE;
		float y = this.RANDOM.nextFloat()*WORLD_SIZE;
		float z = this.RANDOM.nextFloat()*WORLD_SIZE;
		float w = this.RANDOM.nextFloat()*MathConstants.PI;
		Quaternion q = new Quaternion(x, y, z, w);
		q.normalize();
		return q;
	}

	
	

	/** Test if the value is not a number.
	 * 
	 * @param value
	 */
	protected void assertNaN(float value) {
		assertNaN(null, value);
	}

	/** Test if the value is not a number.
	 * 
	 * @param message
	 * @param value
	 */
	protected void assertNaN(String message, float value) {
		if (!Float.isNaN(value)) {
			StringBuilder msg = new StringBuilder();
			if (message!=null) msg.append(message);
			if (msg.length()>0) msg.append(' ');
			msg.append("the value is expected to be not a number, but it is equals to "); //$NON-NLS-1$
			msg.append(value);
			fail(msg.toString());
		}
	}

	
	
	

	/** Asserts that the given value is equal to zero.
	 * 
	 * @param value
	 */
	protected void assertZero(float value) {
		assertZero(null, value);
	}

	/** Asserts that the given value is equal to zero.
	 * 
	 * @param message
	 * @param value
	 */
	protected void assertZero(String message, float value) {
		if (Math.abs(value)==0.) return;
		fail((message==null ? "" : (message+": "))  //$NON-NLS-1$//$NON-NLS-2$
				+"zero is expected"); //$NON-NLS-1$
	}

	/** Asserts that the given value is not equal to zero.
	 * 
	 * @param value
	 */
	protected void assertNotZero(float value) {
		assertNotZero(null, value);
	}

	/** Asserts that the given value is not equal to zero.
	 * 
	 * @param message
	 * @param value
	 */
	protected void assertNotZero(String message, float value) {
		if (Math.abs(value)!=0.) return;
		fail((message==null ? "" : (message+": "))  //$NON-NLS-1$//$NON-NLS-2$
				+"zero is not expected"); //$NON-NLS-1$
	}

	/** Asserts that the given value is equal to zero.
	 * 
	 * @param value
	 */
	protected void assertZero(byte value) {
		assertZero(null, value);
	}

	/** Asserts that the given value is equal to zero.
	 * 
	 * @param message
	 * @param value
	 */
	protected void assertZero(String message, byte value) {
		if (Math.abs(value)==0) return;
		fail((message==null ? "" : (message+": "))  //$NON-NLS-1$//$NON-NLS-2$
				+"zero is expected"); //$NON-NLS-1$
	}

	/** Asserts that the given value is not equal to zero.
	 * 
	 * @param value
	 */
	protected void assertNotZero(byte value) {
		assertNotZero(null, value);
	}

	/** Asserts that the given value is not equal to zero.
	 * 
	 * @param message
	 * @param value
	 */
	protected void assertNotZero(String message, byte value) {
		if (Math.abs(value)!=0) return;
		fail((message==null ? "" : (message+": "))  //$NON-NLS-1$//$NON-NLS-2$
				+"zero is not expected"); //$NON-NLS-1$
	}

	/** Asserts that the given value is equal to zero.
	 * 
	 * @param value
	 */
	protected void assertZero(short value) {
		assertZero(null, value);
	}

	/** Asserts that the given value is equal to zero.
	 * 
	 * @param message
	 * @param value
	 */
	protected void assertZero(String message, short value) {
		if (Math.abs(value)==0) return;
		fail((message==null ? "" : (message+": "))  //$NON-NLS-1$//$NON-NLS-2$
				+"zero is expected"); //$NON-NLS-1$
	}

	/** Asserts that the given value is not equal to zero.
	 * 
	 * @param value
	 */
	protected void assertNotZero(short value) {
		assertNotZero(null, value);
	}

	/** Asserts that the given value is not equal to zero.
	 * 
	 * @param message
	 * @param value
	 */
	protected void assertNotZero(String message, short value) {
		if (Math.abs(value)!=0) return;
		fail((message==null ? "" : (message+": "))  //$NON-NLS-1$//$NON-NLS-2$
				+"zero is not expected"); //$NON-NLS-1$
	}

	/** Asserts that the given value is equal to zero.
	 * 
	 * @param value
	 */
	protected void assertZero(int value) {
		assertZero(null, value);
	}

	/** Asserts that the given value is equal to zero.
	 * 
	 * @param message
	 * @param value
	 */
	protected void assertZero(String message, int value) {
		if (Math.abs(value)==0) return;
		fail((message==null ? "" : (message+": "))  //$NON-NLS-1$//$NON-NLS-2$
				+"zero is expected"); //$NON-NLS-1$
	}

	/** Asserts that the given value is not equal to zero.
	 * 
	 * @param value
	 */
	protected void assertNotZero(int value) {
		assertNotZero(null, value);
	}

	/** Asserts that the given value is not equal to zero.
	 * 
	 * @param message
	 * @param value
	 */
	protected void assertNotZero(String message, int value) {
		if (Math.abs(value)!=0) return;
		fail((message==null ? "" : (message+": "))  //$NON-NLS-1$//$NON-NLS-2$
				+"zero is not expected"); //$NON-NLS-1$
	}

	/** Asserts that the given value is equal to zero.
	 * 
	 * @param value
	 */
	protected void assertZero(long value) {
		assertZero(null, value);
	}

	/** Asserts that the given value is equal to zero.
	 * 
	 * @param message
	 * @param value
	 */
	protected void assertZero(String message, long value) {
		if (Math.abs(value)==0l) return;
		fail((message==null ? "" : (message+": "))  //$NON-NLS-1$//$NON-NLS-2$
				+"zero is expected"); //$NON-NLS-1$
	}

	/** Asserts that the given value is not equal to zero.
	 * 
	 * @param value
	 */
	protected void assertNotZero(long value) {
		assertNotZero(null, value);
	}

	/** Asserts that the given value is not equal to zero.
	 * 
	 * @param message
	 * @param value
	 */
	protected void assertNotZero(String message, long value) {
		if (Math.abs(value)!=0l) return;
		fail((message==null ? "" : (message+": "))  //$NON-NLS-1$//$NON-NLS-2$
				+"zero is not expected"); //$NON-NLS-1$
	}

	/** Asserts that the given value is equal to zero.
	 * 
	 * @param value
	 */
	protected void assertZero(Number value) {
		assertZero(value.floatValue());
	}

	/** Asserts that the given value is equal to zero.
	 * 
	 * @param message
	 * @param value
	 */
	protected void assertZero(String message, Number value) {
		assertZero(value.floatValue());
	}

	/** Asserts that the given value is not equal to zero.
	 * 
	 * @param value
	 */
	protected void assertNotZero(Number value) {
		assertNotZero(value.floatValue());
	}

	/** Asserts that the given value is not equal to zero.
	 * 
	 * @param message
	 * @param value
	 */
	protected void assertNotZero(String message, Number value) {
		assertNotZero(value.floatValue());
	}


	/** Test if two vectors are colinears at epsilon.
	 * 
	 * @param expected
	 * @param actual
	 */
	protected void assertColinear(Vector2f expected, Vector2f actual) {
		if (expected == null && actual == null) return;
		String message = null;
		if (expected!=null) {
			Vector2f e = new Vector2f(expected);
			Vector2f a = new Vector2f(actual);
			e.normalize();
			a.normalize();
			float dotProduct = 1.f - Math.abs(e.dot(a));
			if ((dotProduct >= -0.001) && (dotProduct <= 0.001)) return;

		}
		fail(formatMsg(message, expected, actual));
	}

	/** Test if two vectors are colinears at epsilon.
	 * 
	 * @param expected
	 * @param actual
	 */
	protected void assertColinear(Vector3f expected, Vector3f actual) {
		if (expected == null && actual == null) return;
		String message = null;
		if (expected!=null) {
			Vector3f e = new Vector3f(expected);
			Vector3f a = new Vector3f(actual);
			e.normalize();
			a.normalize();
			float dotProduct = 1.f - Math.abs(e.dot(a));
			if ((dotProduct >= -0.001) && (dotProduct <= 0.001)) return;

		}
		fail(formatMsg(message, expected, actual));
	}
	
	/**
	 * @param message is the message to format
	 * @param expected is the expected value
	 * @param actual is the current value
	 * @return the formated message
	 */
	String formatMsg(String message, Object expected, Object actual) {
		String formatted= ""; //$NON-NLS-1$
		if (message != null)
			formatted= message+" "; //$NON-NLS-1$
		return formatted+"expected:<"+expected+"> but was:<"+actual+">"; //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
	}
	

	/** Test if the given method entity throws the specified exception on the given entity.
	 * 
	 * @param expectedException
	 * @param object
	 * @param methodName
	 * @param values are the values to pass to the methods.
	 */
	protected void assertException(Class<? extends Throwable> expectedException,
			Object object, String methodName, Object... values) {
		assertException(null, expectedException, object, methodName, values);
	}

	/** Test if the given method entity throws the specified exception on the given entity.
	 * 
	 * @param message
	 * @param expectedException
	 * @param object
	 * @param methodName
	 * @param values are the values to pass to the methods.
	 */
	
	protected void assertException(String message, Class<? extends Throwable> expectedException,
			Object object, String methodName, Object... values) {
		Class<?>[] types = new Class<?>[values.length];
		for(int idx=0; idx<types.length; idx++) {
			types[idx] = values[idx].getClass();
		}
		assertException(message, expectedException, object, methodName, types, values);
	}

	/** Test if the given method entity throws the specified exception on the given entity.
	 * 
	 * @param message
	 * @param expectedException
	 * @param object
	 * @param methodName
	 * @param types are the types of the method parameters.
	 * @param values are the values to pass to the methods.
	 */
	
	protected void assertException(String message, Class<? extends Throwable> expectedException,
			Object object, String methodName, Class<?>[] types, Object... values) {
		assert(object!=null);
		Class<?> objType;
		Object obj = object;
		if (obj instanceof Class<?>) {
			objType = (Class<?>)obj;
			obj = null;
		}
		else {
			objType = obj.getClass();
		}
		Method method = null;
		Throwable t = null;
		try {
			method = objType.getMethod(methodName, types);
			if (method==null) {
				fail((message!=null?(message+", ") //$NON-NLS-1$
						:"") //$NON-NLS-1$
						+"unable to find the method "+methodName); //$NON-NLS-1$
				return;
			}
		}
		catch(Exception _) {
			fail((message!=null?(message+", ") //$NON-NLS-1$
					:"") //$NON-NLS-1$
					+"unable to find the method "+methodName); //$NON-NLS-1$
			return;
		}
		try {
			method.invoke(obj, values);
		}
		catch(InvocationTargetException e) {
			if (expectedException.equals(e.getCause().getClass())) return;
			t = e.getCause();
		}
		catch(Throwable e) {
			if (expectedException.equals(e.getClass())) return;
			t = e;
		}
		if (t!=null) {
			fail((message!=null?(message+", ") //$NON-NLS-1$
					:"") //$NON-NLS-1$
					+"the method "+methodName //$NON-NLS-1$
					+" does not thrown the expected exception of type "+expectedException //$NON-NLS-1$
					+". An exception of type "+t.getClass().getName()+" is thrown insteed."); //$NON-NLS-1$ //$NON-NLS-2$
		}
		else {
			fail((message!=null?(message+", ") //$NON-NLS-1$
					:"") //$NON-NLS-1$
					+"the method "+methodName //$NON-NLS-1$
					+" does not thrown the expected exception of type "+expectedException //$NON-NLS-1$
					+". No exception was thrown insteed."); //$NON-NLS-1$
		}
	}

	/** Test if the value is a valid float (not NaN nor Infinity).
	 * 
	 * @param value
	 */
	protected void assertNumber(float value) {
		assertNumber(null, value);
	}

	/** Test if the value is a valid float (not NaN nor Infinity).
	 * 
	 * @param message
	 * @param value
	 */
	protected void assertNumber(String message, float value) {
		if (Float.isInfinite(value) || Float.isNaN(value)) {
			StringBuilder msg = new StringBuilder();
			if (message!=null) msg.append(message);
			if (msg.length()>0) msg.append(' ');
			msg.append("the value is expected to be a valid float value, but it is equals to "); //$NON-NLS-1$
			msg.append(value);
			fail(msg.toString());
		}
	}
	
	/** Forward the specified exception with the pairs
	 * composed by a name and a value.
	 * @param e
	 * @param pairs
	 */
	protected void forwardException(Throwable e, Object... pairs) {
		throw new LogAssertion(e.getLocalizedMessage(), e, pairs);
	}
	
	/** Send a warning to the unit test layer.
	 * 
	 * @param message is the warning message.
	 */
	protected void warning(String message) {
		System.err.println("WARNING: ["+getName()+"()] "+message); //$NON-NLS-1$ //$NON-NLS-2$
	}
}
